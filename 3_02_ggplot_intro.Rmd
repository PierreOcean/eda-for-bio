# Introduction to ggplot2

One of the main reasons data analysts turn to R is for its strong data visualisation capabilities. The R ecosystem includes many different packages that support data visualisation. The three that are used widely used are: 1) the base graphics system, which uses the **graphics** package; 2) the **lattice** package; and 3) the **ggplot2** package. Each of these has its own strengths and weaknesses:

* Base graphics is part of base R---it's available immediately after we start R. It's very flexible and allows us to construct more or less any plot we like. This flexibility comes at a cost though. It's quite easy to get up and running with the base R graphics---there are functions like `plot` and `hist` for making commonly-used figures---but building complex figures is time consuming. We have to write a lot of R code to prepare even moderately complex plots, there are a huge number of graphical parameters to learn, and many of the standard plotting functions are inconsistent in the way they work.

* The **lattice** package was developed by Deepayan Sarkar to implement ideas of Bill Cleveland in his 1993 book, Visualizing Data. The package implements something called Trellis graphics, a very useful approach for graphical exploratory data analysis. Trellis graphics are designed to help us visualise complicated, multiple variable relationships. The **lattice** package has many "high level" functions (e.g. `xyplot`) to make this process easy, but still retains much of the fine-grained control that characterises the standard graphics system. The **lattice** package is very powerful but can be hard to learn.

* The **ggplot2** package was developed by Hadley Wickham to implement some of the ideas in a book called The Grammar of Graphics by Wilkinson (2005). It produces Trellis-like graphics, but is quite different from **lattice** in the way it goes about this. It uses its own mini-language to define graphical objects, adopting the language of Wilkison's book to define these. It takes a little while to learn the basics, but once these have been mastered these it's very easy to produce sophisticated plots with very little R code. The downside of working with **ggplot2** is that it isn't as flexible as base graphics.

We aren't going to survey all three of these plotting systems. There isn't space, and in any case, it's possible to meet most data visualisation needs by becoming proficient with just one of them. This book focuses on **ggplot2**. In many ways the **ggplot2** package hits the 'sweet spot' between standard graphics and **lattice**. It allows us to produce complex visualisations without the need to write lines and lines of R code, but is still flexible enough to allow us to tweak the appearance of a figure so that it meets our specific needs.

## The anatomy of ggplot2 {#anatomy}

The easiest way to learn **ggplot2** is by seeing in in action. Before we dive in it's worth surveying the essential features of the **ggplot2** 'grammar'. Most of this is failry abstract and won't make sense on first reading. This is fine. Abstract ideas like 'aesthetics' and 'geoms' will start to make sense as we work through a range of different examples in the next few chapters.

**ggplot2** is designed to reflect Wilkinson's grammar of graphics. The **ggplot2** version of this grammar revolves around the idea of **layers**. The underlying idea is that we construct a visualisation in a structured manner by defining one or more of these layers, whihc together with a few other components define a complete **ggplot2** object. Each layer may have its own data or it may share its data with another layer, and each layer displays its data in a specific way. The resulting **ggplot2** object is defined by a combination of:

1) a default data set along with a set of mappings from variables to aesthetics,

2) one or more layers, each comprising a number of components,

3) one scale for each aesthetic mapping, 

4) a coordinate system for the plot,

5) a faceting specification that tells **ggplot2** how to define a multi-panel plot. 

We'll skim over each of these in turn before moving onto the business of actually using **ggplot2**.

### Layers

Each layer in a **ggplot2** plot may have five different components, though we don't necessarily have to specify all of these:

* The __data__. At a minimum, every plot needs some data. Unlike base R graphics, **ggplot2** always accepts data in one format, an R data frame (or tibble). Each layer can be associated with it's own data set. However, we don't have explicitly add data to each layer. When we choose not to specify the data set for a layer **ggplot2** will try use the default data if it has been defined.

* A set of __aesthetic mappings__. These describe how variables in the data are associated with the aesthetic properties of the layer. Commonly encountered aesthetic properties include position (x and y locations), colour, and size of the objects on a plot. Each layer can be associated with it's own unique aesthetic mappings. When we choose not to specify these for a layer **ggplot2** will use the defaults if they were defined.

* A __geometric object__, called a 'geom'. The geom tells **ggplot2** how to actually represent the layer---they refer to the objects you can actually see on a plot, such as points, lines or bars. Each geom only works with a particular of aesthetic mappings. We always have to define at least one geom when using **ggplot2**.

* A __stat__. These take the raw data in the data frame and transform in some useful way. A stat allows us to produce summaries of our raw data. We won't use them in this book because we can produce the same kinds of figures by first processing our data with **dplyr**. Nonetheless, the stat facility is one of the things that makes **ggplot2** particularly useful for exploratory data analysis.

* A __position adjustment__. These apply small tweaks to the position of layer elements. These are most often used in plots like bar plots where we need to define how the bars are plotted, but they can occasionally be useful in other kinds of plots. 

### Scales

The scale part of a **ggplot2** object controls how the data is mapped to the aesthetic attributes. A scale takes the data and converts it into something we can perceive, such as a position, or the colour and size of points in a plot. A scale must be defined for every aesthetic in a plot. It doesn't make sense to define an aesthetic mapping without a scale because there is no way for **ggplot2** to know how to go from the data to the aesthetics without one. 

Scales operate in the same way on the data in a plot. If we include several layers they all have to use the same scale for the shared aesthetic mappings. This behaviour is sensible because it ensures that the information that is displayed is consistent.

If we choose not to explicitly define a scale for an aesthetic **ggplot2** will use a default. Very often this will be a 'sensible' choice, which means we can get quite a long way with **ggplot2** without ever really understanding scales. We won't worry too much about them, though we will take a brief look at a few of the more common options.

### Coordinate system

A **ggplot2** coordinate system takes the position of objects (e.g. points and lines) and maps them onto the 2d plane that a plot lives on. Most people are already very familiar with the most common coordinate system (even if they didn't realise it). The Cartesian coordinate system is the one we've all been using ever since we first constructed a graph with paper and pencil at school. All the most common statistical plots use this coordinate system so we won't consider any others in this book.

### Faceting

The idea behind faceting is very simple. Faceting allows us to break a data set up into subsets according to the unique values of one or two variables, and then produce a separate plot for each subset. The result is a multipanel plot, where each panel shares the same layers, scales, etc. The data is the only thing that varies from panel to panel. The result is a kind of 'Trellis plot', similar to those produced by the **lattice** package. Faceting is a very powerful tool that allows us to slice up our data in different ways and really understand the relationship between different variables. Together with aesthetic mappings, faceting allows us to summarise relationships among 4-6 variables in a single plot.

## A quick introduction to ggplot2 {#quick}

Now that we've briefly reviewed the main components of the **ggplot2** grammar we can start learning how to use the package. It uses this grammar to define a sort of mini-language within R, using functions to define things like layers and scales, which are combined to define a **ggplot2** graphics object. Once we a complete object we can use it to display our graphic on the computer screen or save in a particular graphics format (e.g. PDF, PNG, JPEG, and so on). 

Rather than orientating this introduction around each of the key functions we're going to develop a simple example to help us understand how **ggplot2** works. Many of the key ideas you need to understand about **ggplot2** can be taken away from this one example, so it's worth spending a little time really trying to understand it. Use the example understand how the different **ggplot2** functions are related to the grammar outlined above.

Our aim is to produce a scatter plot. Scatter plots use horizontal and vertical axes, the "x" and "y" axes, to plot data as a series of points. They are designed to show how one numeric variable is related to another. Our scatter plots will be constructed using the `storms` data from the **nasaweather**. The question we want to explore is, What is the relationship between the observation year (the `year` variable), wind speed (the `wind` variable), atmospheric pressure (the `pressure` variable), and time of year (the `seasday` variable)? Specifically, we want to know how wind speed depends on atmospheric pressure, and how this relationship changes (if at all) among months and types of storm.

### Making a start

The **ggplot2** package is quite flexible, in the sense that it allows you to construct the a graphical object in a variety of different ways. To keep life simple, we are going to adopt one consistent work flow in this course. It won't reveal the full array of **ggplot2** tricks, but it is enough to allow you to construct a wide range of standard statistical plots.

To begin working with a graphical object we have to first set it up. This is the job of the `ggplot` function. Notice that the package is called **ggplot2**, but the function that does the hard work is called `ggplot`. Try not to mix them up. We can build an empty object by using `ggplot` without any arguments:
```{r}
plt <- ggplot()
summary(plt)
```
Here we constructed the graphical object, assigned it to a variable called `plt`, and then used the `summary` function to inspect the result. If you forget what kind of graphical object you can always use `summary` to get an idea of its structure. The result is... not very much. There are no data, aesthetic mapping, layers, etc associated with `plt`. All we did was set up an empty object, which is not all that useful.

How can we improve on this? We can add a default data set to the object by passing the name of a variable associated with a data frame (or `dplyr` tbl) to `ggplot`. Let's try this, using the `storms` data set.
```{r}
plt <- ggplot(storms)
summary(plt)
```
Now when we summarise the resulting object we can see that the variables that were stored inside `storms` now comprise the data inside the object we named `plt`.

The next step is to add an aesthetic mapping to our graphical object. Remember, these describe how variables in the data are mapped to the aesthetic properties of a layer in our graphic. One way to think about aesthetic mappings is that they define what kind of relationships your plot will describe. Since we're making a scatter plot we need to define mappings for positions on x and y axes. Since we're trying to understand how wind speed depends on atmospheric pressure, we'll associate `wind` with the y axis and `pressure` with the x axis. 

We define an aesthetic mapping with the `aes` ("aesthetic mapping") function, which we can use like this:
```{r}
plt <- plt + aes(x = pressure, y = wind)
```
There are a couple things to take away from this. First, notice that we add an aesthetic mapping to the `plt` object using the `+` operator. This has nothing to do with arithmetic. The **ggplot2** package uses some clever programming tricks to redefine the way `+` works with its own objects, so that it can be used to combine them. This is useful because it makes building up a plot from the various components of the grammar very natural. The second thing to notice is that an aesthetic mapping is defined by one or more name-value pairs, specified as `aes` arguments. The names on the left hand side of each `=` refer to the properties of our graphical object (the x and y positions in this case), and the values on right hand side refer to variable names in the data set. 

Notice that we just overwrote the original `plt` object with the updated version using the assignment operator. We could have created a second object (e.g. called `plt2`), but there is no need to do this. Once again, we can inspect the result using `summary`:
```{r}
summary(plt)
```
As hoped, the data (`data:`) from the original `plt` are still there, but now we can also see that two mappings (`mapping:`) have been defined for the x and y axis positions. In summary, we have used the `ggplot` function along with the `aes` function to set up a graphical object with default data and aesthetic mappings. Any layers that we subsequently add will use these unless we specify different options.

We have not quite reached the point where a complete scatter plot has been specified yet -- i.e something we can actually view -- because we still need to add a layer. Before we do this, we should look at a couple of alternative, but more compact, means of specifying the default data and aesthetic mappings. This produces exactly the same same result as the last couple of steps:
```{r}
plt <- ggplot(storms) + aes(x = pressure, y = wind)
summary(plt)
```
The result is the same as before. This should not surprise you by now. All we did was remove the intermediate step that stored the result of `ggplot(storms)` in `plt`. There is a second, slightly less obvious way of setting up our graphical object though:
```{r}
plt <- ggplot(storms, aes(x = pressure, y = wind))
summary(plt)
```
This produces the same result. In this form however, the `aes` function is used inside `ggplot`, i.e. it supplies the second argument to `ggplot`. This approach is probably the most commonly used for setting up a graphical object with default data and aesthetic mappings, so we will adopt it from now on.

The final step to produce a plotable version of `plt` is to add a layer so that **ggplot2** knows how to render the data in the plot. Remember, each layer needs five different components: data, aesthetic mappings, a geom, a stat and a position adjustment. Since we have already set up the default data and aesthetic mappings, there is no need to define these in the the new layer; **ggplot2** will just use the defaults if we leave them out of the definition. This leaves the geom, stat and position adjustment. It turns out that we do not have to define the stat and position adjustment either. **ggplot2** will adopt "reasonable" default values for these two components of a layer without any further input from us. This means we only have to worry about the type of geom we want to use.

What kind of geom do we need? Remember, scatter plots allow us to explore data as a series of points. This means we need to add a layer that uses the __point__ geom. Here is one way to do this: 
```{r}
plt <- plt + layer(geom = "point")
```
All we did here was take the `plt` object, add a new layer using the `layer` function, and then overwrite the old version of `plt`. As is always the case with **ggplot2**, we add the new component using the `+` symbol. We passed one argument to the `layer` function to define the geom: the name of this argument was `geom`, and the value assigned to it was `"point"`. The `layer` function can be used to construct any kind of layer from its component parts. However, `ggplot` provides a number of helper functions that allow us to add layers according to the type of geom they use. These look like this: `geom_XX`, where `XX` is one of the different possible geoms. An alternative to the last line is therefore:
```{r, eval=FALSE}
plt <- plt + geom_point()
```
This way of defining a layer with a specific geom is probably a bit clearer than the last (and more widely used), so we will adopt it from now on.

We should check the structure of the resulting graphical object one last time to see what we have achieved:
```{r}
summary(plt)
```
The text above the `-----` line is the same as before. It summarises the default data and the aesthetic mapping. The text below this summarises the layer we just added. It tells us that this layer will use the points geom (`geom_point`), the identity stat (`stat_identity`), and the identity position (`position_identity`). The identity stat and identity position were chosen for us. The word "identity" here essentially stands for, "leave the data as is", i.e. `gplot2` will plot the exact data it was given at the appropriate positions on the x and y axes. 

Now `plt` has everything it needs to actually render a figure. How do we do this? All we have to do is print the object:
```{r, fig.width=5, fig.height=5}
plt
```

We have finally made a complete scatter plot. This clearly shows that higher wind speeds are associated with lower pressure systems. Although it looks like this was a lot of work, most of the effort so far has been spent explaining how the different parts of the grammar are implemented with the **ggplot2** functions. In fact, the whole thing can be done in a couple of lines if we want:
```{r, eval = TRUE}
ggplot(storms, aes(x = pressure, y = wind)) + geom_point()
```
I didn't bother to show you the resulting plot, but trust me, it is the same as the previous one.

## Increasing the information density

### Using additional aesthetics

We introduced this example by saying that we were interested in the relationship between the observation year, the type of storm, wind speed atmospheric pressure, and time of year. So far we've only examined   the middle two. How can we learn about relationship of these two variables to time of year (`seasday`)? We need to include information in the `seasday` variable in our graph. That is, we want to map the `seasday` variable to one of the aesthetics. This means we need to change the way we are using `aes`. One option is to map the `seasday` to the point colours so that the colour of the points describes the time of year. Here is how we specify this:

```{r}
plt <- ggplot(storms, aes(x = pressure, y = wind, colour = seasday)) + 
       geom_point()
plt
```

Points are now coloured according to whether they are associated with early (dark blue) or late (light blue) season observations. There is no obvious affect of season, though it is quite hard to be sure because so much overplotting is occurring -- many points occur in the same place. Notice that **ggplot2** automatically adds a legend to the figure to help us interpret it. A colour scale is not much use without a legend.

There is nothing to  map other variables to different aesthetics if we wanted to try to squeeze even more information into this plot. For example, we could map the storm type variable (`type`) to the point shape if we wanted, using `shape = type` inside `aes`. However, this graph is already a bit too crowded, so let's finish this chapter by looking at a different way to examine relationships among variables. 

### Using facets

Remember faceting? This allows us to break up our data set up into subsets according to the unique values of one or two variables, and then produce a separate plot for each subset. What if we want to assess whether or not the wind speed and pressure relationship varies among years? One way to do this is to make a separate scatter plot for each year. Faceting operates on the whole graph, so we can't do it by just changing the properties of a layer. Instead, we have to use a new function to add the faceting information. Here is how we do this using the `facet_wrap` function:

```{r, fig.height=4.3, fig.width=6.7}
plt <- ggplot(storms, aes(x = pressure, y = wind, colour = seasday)) + 
       geom_point() + 
       facet_wrap(~ year, nrow = 2, ncol = 3)
plt
```

The first argument (`~ year`) says to break up the data according to the values of `year`. You need to the `~` at the front by the way. We'll learn what that is doing next year, but for now, take my word for it -- you need to include it for the faceting to work. The `nrow` and `ncol` arguments just specify how to split the panels across rows and columns of the resulting plot. Notice that each panel shares the same scales. This makes it easy to compare information across them. The plot indicates that the wind speed / pressure relationship is more or less invariant across years, and that perhaps 1997 and 2000 were not such bad storm years compared to the others. This probably shouldn't surprise us. Although the occurrence of storms is somewhat stochastic, the laws of atmospheric physics do not change from one year to the next.







