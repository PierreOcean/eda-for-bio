---
layout: default
title: Exercises - functions and vectors 
---

```{r global_options, include=FALSE}
library(knitr)
opts_chunk$set(fig.width=7, fig.height=8, warning=TRUE, error=TRUE, prompt=FALSE)
```

<div class="well">
Today's practical is designed to let you practise carrying out some basic calculations in R. It requires knowledge of the material in the [Using R as a Calculator](http://dzchilds.github.io/aps-data-analysis-L1/quick-introduction.html), [Functions](http://dzchilds.github.io/aps-data-analysis-L1/functions.html), and [Vectors](http://dzchilds.github.io/aps-data-analysis-L1/vectors.html) topics. If you have managed to work through these topics and are feeling reasonably comfortable with basic R calculations, the practical can be done in about 40 minutes. If not, you may need to spend some time reading the relevant material and talking to the TAs. They can tell you where to look for help and are happy to provide hints if you get stuck. Don't spend ages on a problem---ask the TAs or a friendly neighbor for help if you aren't making progress.

Remember, put all of your working into a well-commented and organised script! Once finished, you should be able to close down RStudio, reopen your script, and run it all without errors.
</div>

### Question 1

Take the natural log of 5 and round this to 3 decimal places. Do this with just one line of R code, i.e. make sure you do the whole calculation in one step.

#### Answer

The `log` function takes the natural log of a number (or more accurately, it takes the natural log of the elements of a numeric vector). This function only needs a single argument (called `x`), which is the numeric vector. The `round` function rounds the elements of a numeric vector to a user-specified number of decimal places. This takes two arguments: `x` is the numeric vector, and `digits` is an integer specifying the decimal places. In order to use these two functions together you have to remember to use function nesting, like this:

```{r}
round(x = log(5), digits = 3)
```

You could also have done this without naming either of the arguments...

```{r}
round(log(5), 3)
```

...though it is generally safer to name all but the first argument...

```{r}
round(log(5), digits = 3)
```

### Question 2

By subsetting the built-in `LETTERS` vector, print your first and last names to the Console. You don't have to print both at the same time.

#### Answer

This question requires that we use the square bracket construct (`[`) to subset the correct elements of the `LETTERS` vector (which is just the alphabet in upper case). We can do this in two steps as follows. Let's say your first name is Dylan. The letters "D", "Y", "L", "A" and "N" are at positions 4, 25, 12, 1 and 14 in the alphabet. We first manually construct a numeric vector with these numbers, using the `c` function, and then assign this a name so that we can reuse it:

```{r}
letter.positions <- c(4, 25, 12, 1, 14)
```

Now all we need to do is extract the corresponding letters from the `LETTERS` vector by their position in that vector, using the `[` construct:

```{r}
LETTERS[letter.positions]
```

Obviously the same procedure can be used to extract the letters of a different name. We could also have done this in a single step if we prefer not to store the intermediate step (either approach is fine):

```{r}
LETTERS[c(4, 25, 12, 1, 14)]
```

### Question 3

Make a vector that contains an ascending sequence of numbers. The first element of the vector should be 0 and the last element should be 101, with successive numbers increasing in steps of 0.01 units. Work out the __the length__ of this vector using R (not by hand).

#### Answer

This question requires us to first use the `seq` function to construct the ascending sequence of numbers, setting the `from` argument to 0, the `to` argument to 101, and the `by` argument to 0.01. If we assign the result of this calculation a name, we can then use the `length` argument to calculate the length of the resulting numeric vector (obviously we could work this out by hand, but that is likely to be a more error prone method). The R code to do this is just...

```{r}
num.seq <-seq(from = 0, to = 101, by = 0.01)
length(x = num.seq)
```

### Question 4

Make a repeated sequence of integers ("whole numbers")" that has the following pattern:

```{r, echo=FALSE}
rep(1:3, each = 2, times = 4)
```

This is only a partial sequence. Your vector should contain this repeating sequence but should have exactly 240 elements.

#### Answer

Since we need to make a repeated sequence, we need to use the `rep` function. There are (at least) a couple of different ways to approach the problem. The "cleanest" approach makes use of the `x`, `each` and `times` arguments. The `x` argument is just the starting vector that we want to work on. This should be a vector containing the numbers 1, 2 and 3 in ascending order. We want **each** element of this to first be repeated twice, so we assign the `each` argument a value of 2. We then want the resulting vector to be repeated 40 **times**. This leads to:

```{r}
rep(x = 1:3, each = 2, times = 40)
```

### Question 5

Copy the following into your script:

```{r}
repseq <- rep(1:3, each = 5, times = 5)
```

Now subset the `repseq` vector so that you keep every other element, starting at the element in position 2. That is, subset `repseq` so that you end up with the second element, the fourth element, the sixth element, and so on.

#### Answer

This question requires that we use the square bracket construct (`[`) to subset the correct elements of the `repseq` vector. Since we want every other element, starting at the second, we need to use `seq` to first construct a vector of numbers that reference these positions. We also need to make sure the sequence ends in the right place. Here is one way to do this:

```{r}
positions <- seq(from = 2, to = length(repseq), by = 2)
```

Notice that we used the `length` function with `repseq` to work out how long it is. Once the `positions` vector has been constructed, it is easy to extract the required elements:

```{r}
repseq[positions]
```

This could also have been done in a single step using `repseq[seq(from = 2, to = length(repseq), by = 2)]`

### Question 6

Create a numeric vector containing a decreasing sequence of integers ("whole numbers") from 14 to 3. Assign this to a name of your choice, and then change the 6th element to have a value of 14.

#### Answer

Once again, we need to use the `seq` function to construct the required sequence. This is easy, once you realise that a descending sequence can be generated by assigning a negative number to the `by` argument:

```{r}
myseq <- seq(from = 14, to = 3, by = -1)
myseq
```

We called the result `myseq`. In order to assign a new value of a specific element of `myseq` we have to combine the square bracket construct (`[`) with assignment (`<-`):

```{r}
myseq[6] <- 14
myseq
```

### Question 7

Make numeric vectors containing the two following sets of numbers:

A) 7, 2, 5, 3, 1 
B) 1, 4, 8, 3, 9

(Make sure you assign them the names `A` and `B`)

Write some R code to determine `A + B` and `A + B + 6`. 

Look carefully at the results. What happens when we add two numeric vectors together? What happens when we add a single number to a vector? Do you see how "vectorised" operations work in R?

Now make a new numeric vectors containing the following set of numbers (call it `C`):

C) 1, 2

Add this to the `A` vector. What happens when you add numeric vectors with different lengths?

#### Answer

We first need to use the `c` function to make the required `A` and `B` vectors:

```{r}
A <- c(7, 2, 5, 3, 1)
B <- c(1, 4, 8, 3, 9)
```

The first set of calculations are easy to do: 

```{r}
A + B
A + B + 6
```

The first calculation reminds us that when we add two vectors in R, the calculation is done "element-wise". The second calculation shows that when we add a single number (i.e. a length-one numeric vector), the single number is recycled. The third calculation shows that recycling also applies to any length vector. Since the `C` vector only has a length of two, the values 1 and 2 are recycled element-by-element over the addition to `A`:

```{r, warning=TRUE}
C <- 1:2
A + C
```

Notice that a warning (not an error!) is generated telling us that recycling has occurred. This is because we do not often intentionally use recycling.

### Question 8

Create a numeric vector with elements 3.2, 4.4, and 15. Using this vector, create a new vector by multiplying only the first and third elements by 4. *Hint:* you will need to create a new numeric vector and make use of vectorised multiplication.

#### Answer

There aren't really any new tricks needed to do this exercise. First use the `c` function to make the requested numeric vector (called `mynums` below), then use `c` again to make another vector with the values we need to multiple each element by (called `multip` below), and finally, multiply these two vectors together:

```{r}
mynums <- c(3.2, 4.4, 15)
multip <- c(4, 1, 4)
mynums * multip
```

This works because multiplication occurs element-by-element. As usual, this could all be done in one step without storing the intermediate results.

### Question 9

Create a vector of integers from 0 to 9 and assign this the name `x`. Create an evenly spaced sequence of 10 numbers from 3 to 7 and assign this the name `y`. Use these two vectors to create a logical vector which tells you which elements in `x` are larger than the corresponding elements in `y`. *Hint:* read the section on [logical vectors](http://dzchilds.github.io/aps-data-analysis-L1/vectors.html#other-vectors) in the course book.

#### Answer

The first numeric sequence is easy to make using the `:` operator. The second sequence can be constructed using the `seq` function again, assigning a value of 10 to the `length` argument to control the length (surprise, surprise):

```{r}
x <- 0:9
y <- seq(from = 3, to = 7, length = 10)
```

It is then just a matter of using the "greater than" operator (`>`) to calculate the required logical vector:

```{r}
x > y
```

### Question 10

Write some R code to calculate the volume of a sphere, where total volume V is given by:

$$
V = 4/3 \times \pi r^3
$$

What is the volume of a sphere when the radius is:

a) 4?
b) 5?
c) 6?

How many times bigger is the radius 5 sphere than the radius 4 sphere?

#### Answer

This is a straightforward calculation, and since division (`/`) and exponentiation (`^`) have precedence over multiplication (`*`), we do not even need to use parentheses to control the order of evaluation:

```{r}
# volumes
V4 <- 4/3 * pi * 4^3
V4
V5 <- 4/3 * pi * 5^3
V5
V6 <- 4/3 * pi * 6^3
V6
# ratio of V5 to V4
V5/V4
```

### Question 11

pH is the negative of the logarithm (base 10) of the concentration, measured in units of moles per liter, of hydrogen ions. Calculate the pH of a river sample with a H+ concentration of 2.57 x 10^-7^ M l^-1^. Round your answer to 2 decimal places.

#### Answer

This is again a simple calculation, though we do have to understand how R deals with very large and very small numbers. This means we have to understand [scientific notation](https://en.wikipedia.org/wiki/Scientific_notation) in R. It is very tedious to write out all the zeros when writing a small number like 0.00000012, so like many other computer languages, R allows us to write it as `1.2e-07`. The "e-07" here stands for "x 10^-7^", i.e. it moves the decimal 7 places to the left. Once we understand this the calculation is simple:

```{r}
round(log10(2.57e-7), 2)
```


### Question 12

Use the `seq` function to create a vector containing a sequence of numbers between -1 and 1 in steps of 0.25. Pass this vector (as the argument `x`) to the function `sinpi`. What is returned? Try passing the same vector argument to `cospi`. Now make a new vector of length 9, containing a sequence of numbers that starts at -$pi$ and ends at $pi$. Pass this new vector to the `sin` and `cos` functions.

Do you understand the difference between the `sinpi` and `sin` functions, and the difference between `cospi` and `cos` functions? *Hint:* R uses [radians](https://en.wikipedia.org/wiki/Radian) to define angles.

#### Answer

This exercise is easy to do, but difficult to understand if you haven't studied A-level maths and done any programming before. When a mathematician measures angles they don't use degrees (i.e. there are 360 degrees in one rotation of a circle). Instead they measure angles in something called radians. One full rotation of a circle corresponds to $2\pi$ radians. The `x` argument of the `sinpi` and `cospi` functions is defined such that "sinpi" = $sin(\pi x)$ and "cospi" = $cos(\pi x)$. This means that assigning a value of 1 to `x` corresponds to an angle of $\pi$ radians. If you understand this, then you might expect the sequence from -1 to +1 when used `sinpi` and `cospi` to give the same results as the equivalent sequence from $-\pi$ to $pi$ used with `sin` and `cos`. This isn't quite true though...

```{r}
myseq1 <- seq(from = -1, to = +1, by = 0.25)
sinpi(x = myseq1)
myseq2 <- seq(from = -pi, to = +pi, length = 9)
sin(x = myseq2)
```

The small discrepancy is due to the way computers store numbers with decimals. To cut a very long story short, most of the time they can't store these kinds of numbers this exactly, which occasionally leads to odd results when we carry out calculations on non-integer numbers. It isn't really that important that you understand the whys and hows this, but knowing about it may help you understand seemingly odd results.

### Question 13

You know how to access an element of a vector by its position using the square bracket notation:
```{r}
vec1 <- c(1.1, 2.3, 4.0, 5.7)
vec1[2]
```
Now imagine that you want to access the last element of a vector, but you don't know how long it is. How would you do it? *Hint:* try using the `length` function on a vector.

#### Answer

The hint makes this one is fairly easy. The `length` function returns the length of a vector, i.e. it tells us how many elements a vector has. If we want to access the the last element of a vector we can just use the `length` function on the vector to reference the position of its last element (this is the same thing as its length). The R code to extract the last element of a vector just combines the `[` construct and length, for example...

```{r}
vec1[length(vec1)]
```

### Question 14

Make a vector of the first 100 integers ("whole numbers"). Find the mean and variance of this vector. *Hint:* you will need to find the names of the functions that calculate these quantities. Ask a TA to explain "variance" if you have not come across it before.

#### Answer

There isn't much to say about this question. We just use `:` to make the numerical sequence. We'll learn a bit more about means and variances later. For now, we just needed to know which functions calculate these numbers from a numeric vector. A little bit of Googling or guesswork should have led you to the `mean` and `var` functions:

```{r}
x <- 1:100
mean(x)
var(x)
```

### Question 15

Create a vector containing the letters of the alphabet in reverse order. *Hint:* use the `:` notation or the `seq` function to extract elements of the built-in vector `LETTERS` (or `letters`, either is fine).

#### Answer

If we know that there are 26 letters in the alphabet (we hope you do) then there isn't really very much to this question. We just have to remember that `:` and `seq` can generate descending sequences of numbers and well as ascending sequences:

```{r}
LETTERS[26:1]
```

### Extended exercise

*Brief Background:* The unified neutral theory of biodiversity is a hypothesis that an individual’s species identity is not related to its survival or fitness.  Under neutral theory, mortality and recruitment are random and population size is only constrained by a maximum community size.  While we know that species traits are important at small spatial scales, neutral theory is interesting because it describes many of the patterns we see at larger scales. Here you will simulate a very simple tree community under neutral theory.

a)	Create a character vector containing the letters “a” through “j” and assign it to the name `comm`. This will represent the community, with each element representing an individual and each letter representing a species. *Hint:* use the inbuilt `letters` vector.

b)	Calculate the species richness of this community. Species richness is just the number of unique species in the community. *Hint:* use functions `unique` and `length`.

c)	This bit is quite tricky. We need to be able to choose a random individual to successfully reproduce at each time step. Work out how to select out a random element of `comm` (using R of course!). *Hint:* Use the `sample` function, working with the `x` and `size` arguments. 

d)	We also need to select a random individual to die and be replaced at each time step. To do this, pick out one number at random from the sequence generated by `1:10` (use the same trick you learned above). This will give you the index (i.e. position) of the element to be replaced.

e)	Use square bracket (`[]`) indexing and your answer to (d) to pick out the letter of the individual in `comm` to be replaced.

f)	Combine your answers to (c) and (e) to replace a random element with another. *Hint:* use assignment---the thing on the left to be replaced by the thing on the right.

g)	Run the last step (f) a further 9 times, what has happened to the species richness? What would happen to this community given enough time steps?

#### Answer

This exercise combines many of the ideas explored in the previous questions. We will just list the R code used to solve the problem, rather than going through each step. Feel free to ask a TA for more help if you are unsure why/how any of it works.

a) 

```{r}
comm <- letters[1:10]
```

b) 

```{r}
length(unique(comm))
```

c) 

```{r}
sample(x = comm, size = 1)
```

d) 

```{r}
sample(x = 1:10, size = 1)
```

e)

```{r}
comm[sample(x = 1:10, size = 1)]
```

f) 

```{r}
comm[sample(x = 1:10, size = 1)] <- sample(x = comm, size = 1)
```

g)

```{r}
length(x = unique(x = comm))
```

**Summary answer**

Species richness decreases as species "die" and "reproduce", and the community will ultimately become a monoculture (there will be only one species left). This is because in neutral theory we usually also add a term that allows migration of new species into the community. Without migration, one species will come to dominate due to random drift (i.e. at any point in time, the most abundant species will have the highest chance of being selected to successfully reproduce)









