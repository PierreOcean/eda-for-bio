--- 
title: "APS 135: Introduction to Exploratory Data Analysis with R"
author: "Dylan Z. Childs"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output:
  bookdown::gitbook:
    config:
      toc:
        collapse: section
    includes:
      in_header: extras.css
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
github-repo: dzchilds/eda-for-bio
description: "Course book for Introduction to Exploratory Data Analysis with R (APS 135) in the Department of Animal and Plant Sciences, University of Sheffield."
---
```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```

# Information and overview {-}

This is the online course book for the __Introduction to Exploratory Data Analysis with R__ component of ([APS 135](https://www.shef.ac.uk/aps/currentug/level2/aps135)) module. You can view this book in any modern desktop browser, as well as on your phone or tablet device. The site is self-contained---it contains all the material you are expected to learn this year. [Dylan Childs](https://www.shef.ac.uk/aps/staff-and-students/acadstaff/childs) is the author. Please [email him](mailto:d.childs@sheffield.ac.uk?Subject=APS%20133%20general%20query) if you spot any problems.

## Aims {-}

1. You will be introduced to the R ecosystem. R is now very widely used by biologists and environmental scientists to access data, carry out interactive data analysis, build mathematical models and produce high quality figures. We will teach you a little basic R programming so that you are in a position to address these needs in future if you need to. You don't have to become an expert programmer to have a successful career in science, but knowing a little bit about programming has become (almost) a prerequisite for doing biological research in the 21^st^ century.

2. You will learn how to begin using R to carry out data manipulation and visualisation. Designing good experiments, collecting data, and analysis are hard, and these activities often takes a great deal time and money. If you want to effectively communicate your hard-won, latest, greatest results, it is difficult to beat a good figure or diagram (conversely, if you want to be ignored, put everything into a boring table). R is really good at producing figures, so even if you end up just using it as a platform for visualising data, your time hasn't been wasted.

3. This book provides a foundation for learning statistics later on. If you want to be a biologist, particularly one involved in research, there is really no way to avoid using statistics. You might be able to dodge it by becoming a theoretician, but if that really is your primary interest you should probably being studying for a mathematics degree. For the rest of us who collect data, or at least analyse other people's data, knowing about statistics is essential: it allows us to distinguish between real patterns (the "signal") and chance variation (the "noise").

### Topics {-}

The topics we will cover in this book are divided into three sections:

The __Getting Started with R__ block introduces the R language and the RStudio environment for working with R. We aim to run through much of what you need to know to start using R to improve your productivity. This includes some basic terminology, how to use R packages, and how to access help. As noted earlier, we are not trying to turn you into an expert programmer. That takes too long (not everyone enjoys programming, though many of you may be surprised to discover that you do in fact like it). By the end of this block you will know enough about R to begin learning the more practical material that follows.

The __Data Wrangling with R__ block aims to show you how to manipulate your data with R. The truth is that if you regularly work with data, a large amount of time will inevitably be spent getting data into the format you need. The informal name for this is "data wrangling". This is a topic that is not often taught well to undergraduates, which is a shame, because mastering the art of data wrangling saves you a lot of time in the long run. This block will briefly cover two R packages to help you do this: __dplyr__ and __tidyr__. We'll learn how to get data into and out of R, makes subsets of important variables, create new variables, summarise your data, and so on.

The __Exploratory Data Analysis__ block is all about using R to help you understand and describe your data. The first step in any analysis after you have managed to wrangle the data into shape almost always involves some kind of visualisation and/or numerical summary (or at least that should be the next step if you are serious about getting your analysis right). In this block you will learn how to do this using one of the best plotting systems in R: __ggplot2__. We will review the different kinds of variables you might have to analyse, discuss the different ways you can describe them, both visually and with numbers, and learn how to explore relationships between variables.

## How to use the book {-}

This book covers all the material you need to get to grips with this year, some of which we will not have time to cover in the practicals. **No one is expecting you to memorise everything in the book**. It is designed to serve as a resource for you to refer to over the next 2-3 years (and beyond) as needed. However, you should aim to familiarise yourself with the content so that you know where to look for information or examples when needed. Try to understand the important concepts and then worry about the specific details.

What should you be doing as you read about each topic? There is a lot of R code embedded in the book, most of which you can just copy and paste into RStudio and then run. You are strongly encouraged to do this when you first work through a topic. The best way to learn something like R is to use it actively, not just read about it. Experimenting with different code snippets by changing them is also a very good way to learn what they do. You can't really break R (well you can, but it is quite hard), and working out why something does or does not work will help you learn to use it.

#### Text, instructions, and explanations {-}

Normal text, instructions, explanations etc. are written in the same type as this document, we will tend to use bold for emphasis and italics to highlight specific technical terms when they are first introduced (italics will also crop up with Latin names from time to time, but this is unlikely to produce too much confusion!)

At various points in the text you will come across text in different coloured boxes. These are designed to highlight stand-alone exercises or little pieces of supplementary information that might otherwise break the flow. There are three different kinds of boxes:

```{block, type="action"}
This is an **action** box. We use these when we want to say something important. For example, we might be summarising a key learning outcome or giving you instructions to do something.  
```

```{block, type="warning"}
This is a **warning** box. These contain a warning or a common "gotcha". There are a number of common pitfalls that trip up new users of R. These boxes aim to highlight these and show you how to avoid them. It's a good idea to pay attention to these.
```

```{block, type="info"}
This is an **information** box. These aim to offer a not-too-technical discussion of how or why something works the way it does. You do not have to understand everything in these boxes to use R, but the information will help you understand how it works.
```

#### R code and output in this book {-}

We will try to illustrate as many ideas as we can using snippets of real R code. Stand alone snippets will be formatted like this: 

```{r}
tmp <- 1
print(tmp)
```

At this point it does not matter what the above actually means. You just need to understand how the formatting of R code in this book works. The lines that start with `## ` show us what R prints to the screen after it evaluates an instruction and does whatever was asked of it, that is, they show the output. The lines that __do not__ start with `## ` show us the instructions, that is, they show us the input. So remember, the absence of `## ` shows us what we are asking R to do, otherwise we are looking at something R prints in response to these instructions.

`This typeface` is used to distinguish R code within a sentence of text: e.g. "We use the `mutate` function to change or add new variables."

A sequence of selections from an RStudio menu is indicated as follows: e.g. **File ▶ New File ▶ R Script**

File names referred to in general text are given in upper case in the normal typeface: e.g. MYFILE.CSV.

## Getting help {-}

You will learn various ways of finding help about R in this book. If you find yourself stuck at any point these should your first port of call. If you are still struggling, try the following, in this order:

1. Google is your friend. One of the nice consequences of R's growing popularity and the rise of blogging -- take a look at [R Bloggers](http://www.r-bloggers.com) for a flavour of R-specific blogs -- is that the web is now packed full of useful tutorials and tips, many of which are aimed at beginners. One of the objectives of this book is turn you into a self sufficient useR. Learning how to solve your own R-related problems is an essential pre-requisite for this to happen. Solving your own problems will also help you learn how to use R more effectively.

2. If an hour of Googling does not solve a problem, post a question on the [APS 135 Facebook page](https://www.facebook.com/groups/UoSaps133/). If you find something difficult, the chances are that someone else finds it difficult too. You are strongly encouraged to try to address one anothers' problems via this page. Thinking through and explaining the answer to a question someone else has posed is a __really__ good way of learning. Dylan will check the Facebook page from time to time, and will offer a solution if no-one else has suggested one. We would much prefer you to help each other though.

3. We encourage you to try options 1 and 2 first. Nonetheless, on occasion Google may turn out not to be your friend and a post to the Facebook page might not elicit a satisfactory response. In these instances you are welcome to [email Dylan](mailto:d.childs@sheffield.ac.uk?Subject=APS%20133%20Question) with your query. You are unlikely to receive an answer at the weekend though.

## Updates {-}

We may occasionally decide to update the book in light of the results of comments and questions we receive from you. This is another reason why it is important for you to ask or post questions---it allows us to see where people are struggling. It is also a motivation for choosing to use a website rather than a static document---we can very easily adapt or extend the content to address problems as they arise. If we do update the book, we will let you know what has changed.

<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Get up and running with R and RStudio {-}

## What is R? {-}

The answer to this question very much depends on who we ask. The geeky answer is something like this... 

R is a dialect of the S language, which was developed by John Chambers and colleagues at Bell Laboratories in the mid 1970s. It was designed to offer an interactive  computing environment for statisticians and scientists to carry out data analysis. There are essentially two widely used versions of S (though others have started to appear), a commercial one called S-Plus, and the open source implementation known as R. S-Plus came first, and although it is still around, it is used less each year. Development of R was begun in the late 1990s by two academics, Ross Ihaka and Robert Gentleman, at the University of Auckland. Their motivation was to create an open source language to enable researchers in computational statistics to explore new ideas. That language quickly evolved into something that looked more and more S-like, which we now know as R (GNU R, to be overly precise).

We could go on and on about the various features that R possesses. R is a functional programming language, it supports object orientation, etc etc... but these kinds of explanations are only helpful to someone who already knows about computer languages. It is useful to understand why so many people have turned to R to meet their data analysis needs. When a typical R user talks about "R" they are often referring to two things at once, the GNU R language and the ecosystem that exists around the language:

* R is all about data analysis. We can carry out any standard statistical analysis in R, as well as access a huge array of more sophisticated tools with impressive names like "structural equation model", "random forests" and "penalized regression". These days, when statisticians and computer scientists develop a new analysis tool, they often implement it in R first. This means a competent R user can always access the latest, cutting edge analysis tools. R also has the best graphics and plotting facilities of any platform. With sufficient expertise, we can make pretty much any type of figure we need (e.g. scatter plots, phylogenetic trees, spatial maps, or even [volcanoes](http://www.r-project.org/screenshots/volcano-image.jpg)). In short, R is a very productive environment for doing data analysis.

* Because R is such a good environment for data analysis, a very large community of users has grown up around it. The size of this community has increased steadily since R was created, but this growth has really increased up in the last 5-10 years or so. In the early 2000s there were very few books about R and the main way to access help online was through the widely-feared R mailing lists. Now, there are probably hundreds of books about different aspects of R, online tutorials written by enthusiasts, and many websites that exist solely to help people learn R. The resulting ecosystem is vast, and though it can be difficult to navigate at times, when we run into an R-related problem the chances are that the answer is already written down somewhere^[The other big change is that R is finally starting to become part of the commercial landscape---learning how to use it can only improve your job prospects.].

R is not just about data analysis---though we will mostly use it this way. It is a fully-fledged programming language, meaning that once you become moderately proficient with it you can do things such as construct numerical simulation models, solve equations, query websites, send emails, [access the foaas web service](http://cran.r-project.org/web/packages/rfoaas/), and carry out many other tasks we don't have time to write down. We won't do any of this year or next but it is worth noting that R can do much more than just analyse data if we need it to.

### Getting and installing R {-}

R is open source, meaning anyone can download the source code -- the collection of computer instructions that define R -- and assuming they have enough time, energy and expertise, they are free to alter it as they please. Open source does not _necessarily_ mean free, as in it costs £0 to download and use, but luckily R _is_ free in this sense. If you are working on the University managed desktops it should already have been installed and is ready for you to use. We encourage you to install a copy on your own laptop so that you can work at home, in the library, at a café, or wherever else you find you are productive. Do not use R on its own though. Use it in combination with the RStudio IDE discussed in the next section. 

In order to install R you need to download the appropriate installer from the Comprehensive R Archive Network ([CRAN](http://cran.r-project.org)). We are going to use the "base distribution" as this contains everything you need to use R under normal circumstances. There is a single [installer](http://cran.r-project.org/bin/windows/base/) for Windows. On a Mac, it's important to match the [installer](http://cran.r-project.org/bin/macosx/) to the version of OS X. In either case, R uses a the standard install mechanism that should be familiar to anyone who has installed an application on their machine. There is no need to change the default settings---doing so will probably lead to problems later on.

```{block, type="action"}
Go ahead and install R on your own computer now. You won't be able to make much use of this book without it.
```

After installing R it should be visible in the Programs menu on a Windows computer or in the Applications folder on a Mac. However, it would be a good idea to read the next section before launching R...

## What is RStudio (and why use it)? {-}

R and RStudio are not the same thing. We can run R without RStudio if we need to, but we cannot run RStudio without R. Remember that! R is essentially just a computer program that sits there and waits for instructions in the form of text. Those instructions can be typed in by a user like you or me, or they can be sent to it from another program. This means you can run R in a variety of different environments. The job of RStudio is to provide an environment that makes R a more pleasant and productive tool. One way to get a sense of why RStudio is a Very Good Thing is to look at what running R without it is like. The simplest way to run it on a Linux or Unix-based machine (like a Mac) is to use something called the Terminal. It's well beyond the scope of this book to get into what this is, but in a nutshell, the Terminal provides a low-level, text-based way to interact with a computer. Here is what R looks like running inside a Terminal on a Mac:

```{r, echo=FALSE}
knitr::include_graphics("images/R-terminal.png")
```

We can run R in much the same way on Windows using the "Command Prompt" if we need to. The key thing you need to take away from that screenshot is that running R like this is very "bare bones". We typed the letter "R" in the Terminal and hit Enter to start R. It printed a little information as it started up and then presented us with "the prompt" (`> `), waiting for input. This is where we type or paste in instructions telling R what to do. There is no other way to interact with it when we run R like this -- no menus or buttons, just a lonely prompt.

```{block, type="warning"}
The developers of R on Windows PCs and Macs provide a slightly nicer way to work with R. When we download and install R for either of these two operating systems, in addition to the basic R program that we just saw running in a Terminal, we also get another program that acts as a [Graphical User Interface](http://en.wikipedia.org/wiki/Graphical_user_interface) (GUI) for R. This is the thing labelled "R" in the Programs menu on a Windows computer or the Applications folder on a Mac. If you launch the R GUI on your computer you will be presented with roughly the same thing on either a Windows PC or a Mac. There will be something called the Console, which is where you interact directly with R by typing things at the prompt (which looks like this: `> `), and a few buttons and menus for managing common tasks. We will not go through these two GUIs in any more detail because we are not going to use them. We just need to know they exist so we don't confuse them with RStudio.
```

So what is RStudio? The first thing to note is that it is a different program from R. Remember that! RStudio is installed installed separately from R and occupies its own place in the Programs menu (Windows PC) or Applications folder (Mac). In one sense RStudio is just another Graphical User Interface for R which improves on the "bare bones" experience. However, it is a GUI on steroids. It is more accurate to describe it as an [Integrated Development Environment](http://en.wikipedia.org/wiki/Integrated_development_environment) (IDE). There is no all-encompassing definition of an IDE, but they all exist to make programmer's lives easier by integrating various useful tools into a single piece of software. From the perspective of this book, there are four key features that we care about:

* The R interpreter---the thing that was running in the Terminal above---runs inside RStudio. It's accessed via a window labelled Console. This is where we type in instructions we want to execute when we are working directly with R. The Console also shows us any output that R prints in response to these instructions. So if we just want the "bare bones" experience, we can still have it.  

* RStudio provides facilities for working with R programs using something called a Source Code Editor. An R program ( also called a "script")" is just is a collection of instructions in the R language that have been saved to a text file. Nothing more! However, it is much easier to work with a script using a proper Source Code Editor than an ordinary text editor like Notepad.

* An good IDE like RStudio also gives you a visual, point-and-click means of accessing various language-specific features. This is a bit difficult to explain until we have have actually used some of these, but trust us, being able to do things like manage packages, set working directories, or inspect objects we've made simplifies day-to-day use of R. This especially true for new users.

* RStudio is cross-platform---it will run on a Windows PC, a Linux PC or a Mac. In terms of the appearance and the functionality it provides, RStudio is exactly the same on each of these platforms. If we learn to work with R via RStudio on a Windows PC, it's no problem migrating to a Mac or Linux PC later on if we need to. This is a big advantage for those of us who work on multiple platforms.

We're only going to scratch the surface of what RStudio can do and there are certainly alternative bits of software that could meet our immediate needs. The reason for introducing a powerful tool like RStudio is because one day you may need to access things like debugging facilities, package building tools, repository management. RStudio makes it easy to use these advanced tools.

### Getting and installing RStudio {-}

RStudio is developed and maintained by a for-profit company called... RStudio. They make their money by selling software tools and services related to R and RStudio. The basic desktop version of RStudio is free to download and use though. It can be downloaded from the RStudio [download page](http://www.rstudio.com/products/RStudio/#Desk). The one to go for is the Open Source Edition of RStudio Desktop, __not__ the commercial version of RStudio Desktop. RStudio installs like any other piece of software, so there's nothing to configure after installation.

```{block, type="action"}
If you haven't already done it, go ahead and install RStudio Desktop on your own computer. You are going to need it.
```

### The anatomy of RStudio {-}

Once it's installed RStudio is run like any other stand-alone application, via the Programs menu or the Applications folder on a Windows PC or Mac, respectively^[If you use a computer running Linux we assume you know what you are doing when it comes to installing and running software.]. We'll say this one last time---RStudio only works if we've also installed R. Here is how RStudio appears the first time it runs:

```{r, echo=FALSE}
knitr::include_graphics("images/RStudio-3-pane.png")
```

There are three panes inside a single window, which we have labelled with red numbers. Each of these has a well-defined purpose. Let's take a quick look at these:

1. The large window on the left is the Console. We have already told you what this is for---the Console lets you know what R is doing and provides a mechanism to interact with R by typing instructions. All this happens at the prompt, `> `. We will be working in the Console in a moment so won't say any more about this here.

2. The window at the top right contains two tabs. The first of these, labelled __Environment__, allows us to see all the different R objects we can access. There are also some buttons that help us to get data into and out of R. The second, labelled __History__, allows us to see a list of instructions we've previously sent to R. The buttons in this tab allow us to reuse or save these instructions.

3. The window at the bottom right contains five tabs. The first, labelled __Files__, gives us a way to interact with the files and folders. The next tab, labelled __Plots__, is where any figures we produce are displayed. This tab also allows you to save your figures to file. The __Packages__ tab is where we view, install and update packages used to extend the functionality of R. The __Help__ tab is where you can access and display various different help pages. The __Viewer__ is essentially an embedded web browser for working with interactive output---we won't be using it in this course.

Don't be alarmed if RStudio looks different on your computer. There are a couple of reasons why this might be the case. First, the appearance of RStudio is highly customisable. Take a quick look at the `Tools > Global Options...` window to see what we mean. Second, there is a fourth window that is sometimes be visible when we work with RStudio---the source code Editor we mentioned above. RStudio saves its state between different sessions, so if we have already messed about with RStudio's appearance or left a script open last time we used it you will see these changes.

```{block, type="warning"}
#### RStudio will change over time

Keep in mind that RStudio is very actively developed, which means features tend to appear or change over time. Consequently, if you update it regularly expect the odd thing to change here and there. This is generally a good thing---it usually means new features have been added---but it does require you to occasionally adjust to new additions.
```

## Working at the Console {-}

R was designed to be used interactively---it is what is known as an **interpreted language**, which we can interact with via something called a Command Line Interface (CLI). This is just a fancy way of saying that we can type an instructions to "do something" directly into the Console and those instructions will then be interpreted when we hit the Enter key. If our R expression does not contain any errors, R will then do something like read in some data, perform a calculation, make a figure, and so on. What actually happens obviously depends on what we ask it to do.

Let's briefly see what all this means by doing something very simple with R. Type `1 + 3` at the Console and hit the Enter key:
```{r}
1+3
```
The first line above just reminds us what we typed into the Console. The line after that beginning with `## ` shows us what R printed to the Console after reading and evaluating our instructions. 

What just happened? We can ignore the `[1]` bit for now (the meaning of this will become clear later in the course). What are we left with -- the number 2. The instruction we gave R was in effect "evaluate the expression `1 + 3`". R read this in, decided it was a valid R expression, evaluated the expression, and then printed the result to the Console for us. Unsurprisingly, the expression `1 + 3` is a request to add the numbers 1 and 3, and so R prints the number 4 to the Console.

OK, that was not very exciting. In the next chapter we will start learning to use R to carry out more useful calculations. The important take-away from this is that this sequence of events---reading instructions, evaluating those instructions and printing their output---happens every time we type or paste something into the Console and hit Enter. The printing bit is optional by the way. Whether or not it happens depends on whether you decide to capture the output or not. Just remember, if R does not print anything to the Console it does not necessarily mean nothing has happened.

```{block, type="info"}
Why do we keep using that word _expression_? It has a very specific meaning in computer science. The [Wikipedia page](http://en.wikipedia.org/wiki/Expression_(computer_science)) says:

> An expression in a programming language is a combination of explicit values, constants, variables, operators, and functions that are interpreted according to the particular rules of precedence and of association for a particular programming language, which computes and then produces another value.

That probably doesn't make much sense, but it at least demonstrates why we don't let computer scientists teach biologists about programming. In simple terms, an R expression is a small set of instructions written in human readable(ish) text that tell R to do something. That’s it. We could write "instructions" instead of "expressions" throughout this book but we may as well use the correct word. Whatever we call them, our aim is to learn how to combine sequences of expressions to Get Things Done in R. That's what this book is about.
```










<!--chapter:end:0_01_R_and_RStudio.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# (PART) Introduction to R {-}


<!--chapter:end:1_00.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# A quick introduction to R

## Using R as a big calculator {#r-calculator}

### Basic arithmetic

The end of the [Get up and running with R and RStudio] chapter demonstrated that R can handle familiar arithmetic operations: addition, subtraction, multiplication, division. If we want to add or subtract a pair of numbers just place the `+` or `-` symbol in between two numbers, hit Enter, and R will read the expression, evaluate it, and print the result to the Console. This works exactly as we expect it to:
```{r}
3 + 2
5 - 1
```
Multiplication and division are no different, though we don't use `x` or `÷` for these operations. Instead, we use `*` and `/` to multiply and divide:
```{r}
7 * 2
3 / 2
```
We can also exponentiate a numbers: raise one number to the power of another. We use the `^` operator to do this:
```{r}
4^2
```
This raises 4 to the power of 2 (i.e. we squared it). In general, we can raise a number `x` to the power of `y` using `x^y`. Neither `x` or `y` need to be a whole numbers either.

Arithmetic operations can also be combined into one expression. Assume we want to subtract 6 from 2^3^. The expression to perform this calculation is:
```{r}
2^3 - 6
```
$2^3=8$ and $8-6=2$. Simple enough, but what if we had wanted to carry out a slightly longer calculation that required the last answer to then be divided by 2? This is the **wrong** the way to do it:
```{r}
2^3 - 6 / 2
```
The answer we were looking for is $1$. So what happened? R evaluated $6/2$ first and then subtracted this answer from $2^3$.

If that's obvious, great. If not, it's time to learn a bit about the __order of precendence__ used by R. R uses a standard set of rules to decide the order in which arithmetic calculations feed into one another so that it can unambiguously evaluate any expression. It uses the same order as every other computer language, which thankfully is the same one we all learned in mathematics class at school. The order of precedence used is:

1. exponents and roots ("taking powers")

2. multiplication and division 

3. additional and subtraction

```{block, type="info"}
#### BODMAS and friends

If you find it difficult to remember order of precedence used by R, there are a load of [mnemonics](http://en.wikipedia.org/wiki/Order_of_operations#Mnemonics) that can to help. Pick one you like and remember that instead.
```

In order to get the answer we were looking for we need to take control of the order of evaluation. We do this by enclosing grouping the necessary bits of the calculation inside parentheses ("round brackets"). That is, we place `(` and `)` either side of them. The order in which expressions inside different pairs of parentheses are evaluated follows the rules we all had to learn at school. The R expression we should have used is therefore:
```{r}
(2^3 - 6) / 2
```
We can use more than one pair of parentheses to control the order of evaluation in more complex calculations. For example, if we want to find the cube root of 2 (i.e. 2^1/3^) rather than 2^3^ in that last calculation we would instead write:
```{r}
(2^(1/3) - 6) / 2
```
The parentheses around the `1/3` in the exponent are needed to ensure this is evaluated prior to being used as the exponent.

### Problematic calculations

Now is a good time to highlight how R handles certain kinds of awkward numerical calculations. One of these involves division of a number by 0. Some programming languages will respond to an attempt to do this with an error. R is a bit more forgiving:
```{r}
1/0
```
Mathematically, division of a finite number by `0` equals A Very Large Number: infinity. R has a special built in data value that allows it to handle this kind of thing. This is `Inf`, which of course stands for "infinity". The other special kind of value we sometimes run into can be generated by numerical calculations that don't have a well-defined result. For example, it arises when we try to divide 0 or infinity by themselves:
```{r}
0/0
```
The `NaN` in this result stands for Not a Number. R produces `NaN` because $0/0$ is not defined mathematically: it produces something that is Not a Number. The reason we are pointing out `Inf` and `NaN` is not because we expect to use them. It's important to know what they represent because they often arise as a result of a mistake somewhere in a program. It's hard to track down such mistakes if we don't know how `Inf` and `NaN` arise.

That is enough about using R as a calculator for now. What we've seen---even though we haven't said it yet---is that R functions as a REPL: a read-eval-print loop (there's no need to remember this term). R takes user input, evaluates it, prints the results, and then waits for the next input. This is handy, because it means we can use it interactively, working through an analysis line-by-line. However, to use R to solve for complex problems we need to learn how to store and reuse results. We'll look at this in the next section.

```{block, type="speed"}
#### Working efficiently at the Console

Working at the Console soon gets tedious if we have to retype similar things over and over again. There is no need to do this though. Place the cursor at the prompt and hit the up arrow. What happens? This brings back the last expression sent to R's interpreter. Hit the up arrow again to see the last-but-one expression, and so on. We go back down the list using the down arrow. Once we're at the line we need, we use the left and right arrows to move around the expression and the delete key to remove the parts we want to change. Once an expression has been edited like this we hit Enter to send it to R again. Try it!
```

## Storing and reusing results  {#assignment}

So far we've not tried to do anything remotely complicated or interesting, though we now know how to construct longer calculations using parentheses to control the order of evaluation. This approach is fine if the calculation is very simple. It quickly becomes unwieldy for dealing with anything more. The best way to see what we mean is by working through a simple example---solving a quadratic equation. Quadratic equations looks like this: $a + bx + cx^2 = 0$. If we know the values of $a$, $b$ and $c$ then we can solve this equation to find the values of $x$ that ensure the left hand side equals the right hand side. Here's the well-known formula for these solutions:
$$
x = \frac{-b\pm\sqrt{b^2-4ac}}{2a}
$$
Let's use R to calculate these solutions for us. Say that we want to find the solutions to the quadratic equation when $a=1$, $b=6$ and $c=5$. We just have to turn the above equation into a pair of R expressions:
```{r}
(-6 + (6^2 -4 * 1 * 5)^(1/2)) / (2 * 1)
```
```{r}
(-6 - (6^2 -4 * 1 * 5)^(1/2)) / (2 * 1)
```
The output tells us that the two values of $x$ that satisfy this particular quadratic equation are -1 and -5. What should we do if we now need to solve a different quadratic equation? Working at the Console, we could bring up the expressions we typed (using the up arrow) and then go through each of these, changing the numbers to match the new values of $a$, $b$ and $c$. Editing individual expressions like this is fairly tedious, and more importantly, it's fairly error prone because we have to make sure we substitute the new numbers at exactly the right positions.

A partial solution to this problem is to store the values of $a$, $b$ and $c$. We'll see precisely why this is useful in a moment. First, we need to learn how to store results in R. The key to this is to use the __assigment operator__, written as a left arrow ` <- `. Sticking with our original example, we need to store the numbers 1, 6 and 5. We do this using three expressions, one after the another: 
```{r}
a <- 1
```
```{r}
b <- 6
```
```{r}
c <- 5
```
Notice that we don't put a space between `<` and `-`---R won't like it if we try to add one. R didn't print anything to screen, so what actually happened? We asked R to first evaluate the expression on the right hand side of each ` <-` (just a number in this case) and then __assign the result__ of that evaluation instead of printing it. Each result has a name associated with it, which appears on the left hand side of the ` <- `.

```{block, type="speed"}
#### RStudio shortcut

We use the assignment operator ` <- ` all the time when working with R, and because it's inefficient to have to type the `<` and `-` characters over and over again, RStudio has a built in shortcut for typing the assignment operator: Alt + `-` . Try it. Move the curser to the Console, hold down the Alt key ('Option' on a Mac), and press the `-` sign key. RStudio will auto-magically add insert ` <- `. 
```

The net result of all this is that we have stored the numbers 1, 6 and 5 somewhere in R, associating them with the letters `a`, `b` and `c`, respectively. What does this mean? Here's what happens if we type the letter `a` into the Console and hit Enter:
```{r}
a
```
It looks the same as if we had typed the number `1` directly into the Console. The result of typing `b` or `c` is hopefully obvious. What we just did was to store the output that results from evaluating three separate R expressions, associating each a name so that we can access them again^[Technically, this is called __binding__ the name to a value. You really don't need to remember this though.]. 

Whenever we use the assignment operator ` <- ` we are telling R to keep whatever kind of value results from the calculation on the right hand side of ` <- `,  giving it the name on the left hand side so that we can access it later. Why is this useful? Let's imagine we want to do more than one thing with our three numbers. If we want to know their sum or their product we can now use:
```{r}
a + b + c
```
```{r}
a * b * c
```
So once we've stored a result and associated it with a name we can reuse it wherever it's needed. Returning to our motivating example, we can now calculate the solutions to the quadratic equation by typing these two expressions into the Console:
```{r}
(-b + (b^2 -4 * a * c)^(1/2)) / (2 * a)
```
```{r}
(-b - (b^2 -4 * a * c)^(1/2)) / (2 * a)
```
Imagine we'd like to find the solutions to a different quadratic equation where $a=1$, $b=5$ and $c=5$. We just changed the value of $b$ here to keep things simple. To find our new solutions we have to do two things. First we change the value of the number associated with `b`...
```{r}
b <- 5
```
...then we bring up those lines that calculate the solutions to the quadratic equation and run them, one after the other:
```{r}
(-b + (b^2 -4 * a * c)^(1/2)) / (2 * a)
```
```{r}
(-b - (b^2 -4 * a * c)^(1/2)) / (2 * a)
```
We didn't have to retype those two expressions. We could just use the up arrow to bring each one back to the prompt and hit Enter. This is much simpler than editing the expressions. More importantly, we are beginning to see the benefits of using something like R: we can break down complex calculations into a series of steps, storing and reusing intermediate results as required.

## How does assignment work?

It's important to understand, at least roughly, how assignment works. The first thing to note is that when we use the assignment operator ` <- ` to associate names and values, we informally refer to this as creating (or modifying) __a variable__. This is much less tedious than using words like "bind", "associate", value", and "name" all the time. Why is it called a variable? What happens when we run these lines:
```{r}
myvar <- 1
myvar <- 7
```
The first time we used ` <- ` with `myvar` on the left hand side we __created__ a variable `myvar` associated with the value 1. The second line `myvar <- 7` __modified__ the value of `myvar` to be 7. This is why we refer to `myvar` as a variable: we can change the its value as we please. What happened to the old value associated with `myvar`? In short, it is gone, kaput, lost... forever. The moment we assign a new value to `myvar` the old one is destroyed and can no longer be accessed. Remember this.

Keep in mind that the expression on the right hand side of ` <- ` can be any kind of calculation, not just just a number. For example, if I want to store the number 1, associating it with `answer`, I could do this:
```{r}
answer <- (1 + 2^3) / (2 + 7)
```
That is a strange way to assign the number 1, but it illustrates the point. More generally, as along as the expression on the right hand side generates an output it can be used with the assignment operator. For example, we can create new variables from old variables:
```{r}
newvar <- 2 * answer
```
What happened here? Start at the right hand side of ` <- `. The expression on this side contained the variable `answer` so R went to see if `answer` actually exists in the global environment. It does, so it then substituted the value associated with `answer` into the requested calculation, and then assigned the resulting value of 2 to `newvar`. We created a new variable `newvar` using information associated with `answer`.

Now look at what happens if we just copy a variable using the assignment operator:
```{r}
myvar <- 7
mycopy <- myvar
```
At this point we have two variables, `myvar` and `mycopy`, each associated with the number 7. There is something very important going on here: each of these is associated with a __different copy__ of this number. If we change the value associated with one of these variables it does not change the value of the other, as this shows:
```{r}
myvar <- 10
```
```{r}
myvar
```
```{r}
mycopy
```
R always behaves like this unless we work hard to alter this behaviour (we never do this in this book). So remember, every time we assign one variable to another, we actually make a completely new, independent copy of its associated value. For our purposes this is a good thing because it makes it much easier to understand what a long sequence of R expressions will do. That probably doesn't seem like an obvious or important point, but trust us, it is.

## Global environment

Whenever we associate a name with a value we create a copy of both these things somewhere in the computer's memory. In R the "somewhere" is called an environment. We aren't going to get into a discussion of R's many different kinds of environments---that's an advanced topic well beyond the scope of this book. The one environment we do need to be aware of though is the __Global Environment__.

Whenever we perform an assignment in the Console the name-value pair we create (i.e. the variable) is placed into the Global Environment. The current set of variables are all listed in the __Environment__ tab in RStudio. Take a look. Assuming that at least one variable has been made, there will be two columns in the __Environment__ tab. The first shows us the names of all the variables, while the second summarises their values.

```{block, type="warning"}
#### The Global Environment is temporary

By default, R will save the Global Environment whenever we close it down and then restore it in the next R session. It does this by writing a copy of the Global Environment to disk. In theory this means we can close down R, reopen it, and pick things up from where we left off. Don't do this---it only increases the risk of making a serious mistake. Assume that when R and RStudio are shut down, everything in Global Environment will be lost.
```

## Naming rules and conventions

We don't have to use a single letter to name things in R. The words `tom`, `dick` and `harry` could be used in place of `a`, `b` and `c`. It might be confusing to use them, but `tom`, `dick` and `harry` are all legal names as far as to R is concerned:

* A legal name in R is any sequence of letters, numbers, `.`, or `_`, but the sequence of characters we use must begin with a letter. Both upper and lower case letters are allowed. For example, `num_1`, `num.1`, `num1`, `NUM1`, `myNum1` are all legal names, but `1num` and `_num1` are not because they begin with `1` and `_`.

* R is case sensitive---it treats upper and lower case letters as different characters. This means that `num` and `Num` are treated as distinct names. Forgetting about case sensitivity is a good way to create errors when using R. Try to remember that.

```{block, type="warning"}
#### Don't begin a name with `.`

We are allowed to begin a name with a `.`, but this usually is A Bad Idea. Why? Because variable names that begin with `.` are hidden from view in the Global Environment---the value it refers to exists but it's invisible. This behaviour exists to allow R to create invisible variables that control how it behaves. This is useful, but it isn't really meant to be used by the average user.
```




                                                                                                                                                                                                                                     


<!--chapter:end:1_02_R_calculator.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Building scripts {#scripts}

## Introduction

We have seen that using variables is useful because it enables us to break down a problem into a series of simpler steps. So far however, we have only been working in the Console. If we want to reuse a calculation when we're working like this, we have to change a variable or two and then evaluate the expressions that do the job of solving an equation, make a graph, whatever. We also have to do all of this in the correct order, or things will not work as intended.

```{block, type="warning"}
Working directly at the Console like this is the simplest way to use R. Generally speaking, we do not recommend working this way unless you only need to do something very simple which involves a handful of steps. For more complicated activities you should store your instructions in a script. We will look at how to do this at the end of this chapter. The aim of this section is to demonstrate how to use R to perform simple calculations and introduce a few key concepts that will help you understand how R works. At this stage -- for the purposes of learning how to use R -- typing expressions directly into the Console is fine.
```

You can see that working in the Console is not going to be practical most of the time. So what should we do? The answer is: put your sequence of R expressions into a text file, called a __script__ (We already told you the answer earlier). Calling it a script makes it sound a bit fancy and clever---"I spent all day debugging my script". It is not. It is a boring text file that could be opend up in something like Notepad.exe. We just call it a script to signify the fact that the text contained in the file is a series of instructions telling our computer to do something.

## Writing scripts in RStudio

To open a new script in RStudio navigate to `File > New File > R Script`. This will open the new file in a fourth pane. This pane is the Source Code Editor we mentioned in the [Get up and running with R and RStudio] chapter. The name of the tab where this new file lives will be set to __Untitled1__ if you haven't opened any other new R Scripts. Here is what RStudio looks like after we do this (we've highlighted the new pane with a red asterisk):

```{r, echo=FALSE}
knitr::include_graphics("images/RStudio-4-pane.png")
```

When you work with a script you type the required sequence of R expressions into the Editor pane, **not directly into the Console**. This is important---if you mix and match you will make mistakes. The worst of these is that you will write a script that seems to work, only to find it is broken when you open it up and use it again later. This usually happens because you typed something into the Console that is needed to make the whole script run when you were preparing it, but then forget to put it into the script. Just don't mix and match between using the Console and the Editor and you will avoid this.

The easiest way to appreciate the benefits of using a script is to work with one. If you have not already done so, open up a new script using `File > New File > R Script` and copy-paste this into the Editor pane:
```{r, eval=FALSE}
a <- 1
b <- 6
c <- 5

sqrt.b2ac <- (b^2 -4 * a * c)^(1/2)

(-b + sqrt.b2ac) / (2 * a)
(-b - sqrt.b2ac) / (2 * a)
```
Here is a partial screenshot of the Editor pane showing this script on our computer:

```{r, echo=FALSE}
knitr::include_graphics("images/editor-eg.png")
```

MISSING SENTENCE. Syntax highlighting is a must have feature of any Editor. In a nutshell, syntax is a bit like the grammar of a computer language. It is the set of rules that determine how we form valid expressions, assign variables, and so on. The purpose of syntax highlighting is to draw attention to different components of syntax. You can see that when we use the Cobalt highlighting option, RStudio sets the background to black and displays variables in white, parentheses and arithmetic operators in orange, and numbers in red. It doesn't matter so much what the colours are. What matters is that we have a visual means to distinguish these different kinds of elements, making it much easier to read a script.

```{block, type="speed"}
#### Choose your own colour scheme

The first thing you will probably notice is that this Editor looks a little different from yours. We said earlier that RStudio was highly customisable. What we did above was change the way it does something called __syntax highlighting__. You can do this by navigating to `Tools > Global Options...`, selecting the `Appearance` button, and picking the `Cobalt` option under `Editor theme` (try it!). 
```

The other kind of elements RStudio has highlighted are in blue. We added these. They are called comments. Comments in R always start with a `#` symbol---this is called the "hash"" symbol if you are British (or the "pound" symbol if you are North American). **Lines that start with `#` are completely ignored by R**. They exist only to allow us, the developers of a script, to add notes and explanations that remind us how it all works. 

```{block, type="warning"}
#### Comments are important

At this point we just want to emphasise that __you should use comments__ to remind yourself what your R code is supposed to be doing. Use them liberally to help you understand the logic of each script you write. This is another "take our word"" for it situation -- if you do not use comments, then when you come back to your precious script in a few weeks/months/years time you will have no idea what it does. 
```

## Running scripts in RStudio

The whole point of writing a script is ultimatley to run it. The phrase "run our code" is shorthand for "send a number of R expressions to the R interpreter to be read and evaluated". The latter is tedious to write (and read) over and over again, so we will just write "run your/my/our code". We could run the code in the above script by copying and pasting it into the Console, but this is inefficient. Instead of relying on cut and paste, RStudio gives us different ways to run our code:

* There is a `Run` button at the top right of the Editor pane. As you might imagine, clicking on this will run some code. If you haven't highlighted anything in the Editor, this runs whichever line the cursor is at, i.e. it runs just that one line. If you had highlighted a region inside the Editor, this button will run all of that in sequence.

* We do not like clicking buttons. If you are like us, you are in luck. Pressing Control+Enter (or Command+Enter on a Mac) does exactly the same thing as the `Run` button. It also uses the same rules to decide which bits of code to run or not^[We can also run lines of code via the `Code > Run Lines`. This is easily the most inefficient method after cut and paste. It's only there in case we forget our keyboard shortcut or cannot remember where the run button is.].

Using which ever method you prefer, run every line in the script you just started. Here is what should happen at the Console when you do this:
```{r}
a <- 1
b <- 6
c <- 5

sqrt.b2ac <- (b^2 -4 * a * c)^(1/2)
```
```{r}
(-b + sqrt.b2ac) / (2 * a)
```
```{r}
(-b - sqrt.b2ac) / (2 * a)
```
This works exactly as though you had typed or pasted the sequence of R expressions into the Console, hitting Enter each time you get to the end of a line. What this means is that we can use this script to find the solutions to any quadratic equation with real roots (if you know what we mean by the phrase "real roots", great, if not, it does not really matter). All you have to do is edit the values assigned to `a`, `b` and `c` and then rerun **the whole script**. Do not rerun bits of it. Rerun it all. Try it. Just be sure to only use sets of values where $b^2 > 4ac$ or you will see the dreaded `NaN`.

Now that we have a script that does something a little useful we might wish to use it again. It is just a text file, so we can save the script as we would any other file. We can do this using the familiar menu-based approach (`File > Save As...`) or via the keyboard shortcut `Control+S` (or `Command+S` on a Mac). The only thing to keep in mind is that you should use the file extension `.R` or `.r`, e.g. `my_great_script.R`. This is because RStudio uses the file extension to detect the fact that a file is a script and not an ordinary text file. If you do not do this, then next time you open up the file in RStudio you won't be able to access the fancy Editor features like syntax highlighting, nor will you be able to send lines to the Console without using copy-paste.

From now on you should always work with scripts. No more typing into the Console!

## Spotting problems

We may as well get something out of the way early on: you __will__ ask R to do something that turns out to contain an error. 

Mistakes happen all the time when 

You will do this a lot. It's not a problem when this happens. When it does though, it's important to step back and work out what went wrong.

### The dreaded `+`

Be careful when you highlight code to run. RStudio will run exactly the text you highlight. If you start or finish the highlighted region in the middle of an expression then one of three things will usually happen. If you are lucky you will generate an error, since you end up running only part an expression that is not itself a valid expression. We say this is lucky because the error will at least be easy to spot. If you are unlucky, you might end up running part an expression that _is_ itself a valid expression. This is harder to spot because it won't generate an error, and it will probably create problems further down the line. 

The third outcome is that your Console will look something like this (ignore the colours -- we am still using that Cobalt theme):

```{r, echo=FALSE}
knitr::include_graphics("images/dreaded-plus.png")
```

What happened? Look carefully at the little snippet of R code we sent to the Console. It is not a complete R expression because it is missing a closing parenthesis, `)`. When R receives only part of an expression like this, which has correct syntax but is not complete, it sits and waits for the rest of the expression. This is what the `+` at the Console signifies. When you see this happen you have two options. You can manually type in the missing part of the expression and hit Enter, or you can hit the Escape key to return you to the prompt `>` and start again. The first option is very error prone, so we would generally do the latter.

### Errors

Here is an example of what happens at the Console when you generate an error:
```{r, error=TRUE}
xyz + 2
```
In general terms, what happened is that R read in the instruction `xyz + 2`, tried to evaluate it, and found it could not. This is because the variable `xyz` does not exist. Upon running into the error, R printed something to the screen to tell us we have made a mistake ("Error: object 'xyz' not found"). 

When this happens we say R has "thrown an error". We know this because the message is in a warning colour (prbably red or orange---it depends how RStudio is set up) and it contains the word `Error`. The bit after the `:` is an attempt by R to tell me what went wrong. You should always __read your error messages__. They will be incomprehensible at first, but as you fix the many mistakes you will inevitably make, they will start to make more sense and become helpful (usually---sometimes they make no sense whatsoever, even to experienced users). This way of learning only works if you read the error messages in the first place though.

<!--chapter:end:1_03_building_scripts.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Using functions

## Introduction {#intro-functions}

Functions are a basic building block of any programming language. If you want to use R effectively---even if your needs are very simple---you need to understand how to use functions. We are not aiming to unpick the inner workings of functions in this course. That is an advanced topic that is best saved for a future time when you have gained much more experience of using them^[At some point, if you really want to understand what happens when you use a function you will need to grapple with ideas like _lazy evaluation_, _environments_ and _scoping_.]. The aim of this chapter is to explain what functions are for, how to use them, and how to avoid mistakes when doing so.

## Functions and arguments

The job of each function in R is to carry out some kind of calculation or computation that would typically require many lines of R code to do "from scratch". Functions allow us to reuse common computations while offering some control over the precise details of what actually happens. The best way to see what we mean by this is to see one in action. The `round` function is used to round one or more number(s) to a significant number of digits. To use it, we could type this into the Console and hit Enter:
```{r, eval=FALSE}
round(x = 3.141593, digits = 2)
```
We have suppressed the output for now so that we can unpack things a bit first. Every time we use a function we always have to work with the same basic construct (there are a few exceptions, but we can ignore these for now). We start with the name of the function, that is, we use the name of the function as the prefix. In this case, the function name is `round`. After the function name, we need a pair of opening and closing parentheses. It is this combination of name and parentheses that that alerts R to fact that we are trying to use a function. Whenever you see name followed by opening and closing parentheses you are seeing a function in action.

What about the bits inside the parentheses? These are called the __arguments__ of the function. That is a horrible name, but it is the one that everyone uses so you will have to get used to it. Depending on how it was defined, a function can take zero, one, or more arguments. We will discuss this idea in more detail later in this section. 

In the simple example above, we used the `round` function with two arguments. Each of these was supplied as a name-value pair, separated by a comma. When working with arguments, name-value pairs occur either side of the equals (`=`) sign, with the __name__ of the argument on the left hand side and the __value__ it takes on the right hand side (notice that the syntax highlighter we used to make this website helpfully colours the argument names differently from the values). The name serves to identify which argument we are working with, and the value is the thing that controls what that argument does in the function. 

We refer to the process of associating argument names and values as "supplying the arguments" of the function (sometimes we also say "setting the arguments"). Notice the similarly between supplying function arguments and the assignment operation discussed in the last topic. The difference here is that name-value pairs are associated with the `=` symbol. This association is also temporary: it only lasts as long as it takes for the function to do whatever it does.

```{block, type="warning"}
#### Use `=` to assign arguments

__Do not__ use the assignment operator ` <- ` inside the parentheses when working with functions. This is a "trust us" situation: you will end up in all kinds of difficulty if you do this.
```

The names of the arguments that we are allowed to use are typically determined for us by the function. That is, we are not free to choose whatever name we like. We say "typically", because R is a very flexible language and so there are certain exceptions to this simple rule of thumb. For now it is simpler to think of the names as pre-determined by whatever function you are using though. The arguments control the behaviour of a function. Our job as users is to set the values of the these to get the behaviour we want. By now it is now probably fairly obvious what is going to happen when we used the `round` function like this at the Console:

```{r}
round(x = 3.141593, digits = 2)
```

Remember, we said the `round` function rounds one or more numbers to a number of significant digits. The argument that specifies the focal number(s) is `x`; the second argument, `digits`, specifies the number of decimal places we require. Based on the supplied values of these arguments, `3.141593` and `2`, respectively, the `round` function spits out a value of `3.14`, which is then printed to the Console. If we had wanted to the answer to 3 significant digits we would use `digits = 3`. This is what we mean when we say the values of the supplied arguments controls the behaviour of the function.

## Evaluating arguments and returning results

Whenever R evaluates a function we refer to this action as "calling the function". In our simple example, we called the `round` function with arguments `x` and `digits` (in this course we treat the phrases "use the function" and "call the function" as synonyms, as the former is more natural to new users). What we have just seen---though you may not realise it yet---is that when we call functions they first __evaluate__ their arguments, then perform some kind of action, and finally (optionally) __return__ a value to us when they finish doing whatever it is they do

We will discuss that word "return" in a moment. What do we mean by the word "evaluate" in this context? Take a look at this second example which uses `round` again:
```{r}
round(x = 2.3 + 1.4, digits = 0)
```
When you call a function, what typically happens is that everything on the right hand side of an `=` is first evaluated, the result of this evaluation becomes associated with the corresponding argument name, and then the function does its calculations using the resulting name-value pairs. We say "typically" because other kinds of behaviours are possible---remember, R is a very flexible language---though for the purposes of this course we can assume that what we just wrote is always true. What happened above is that R evaluated `2.3 + 1.4`, resulting in the number `3.7`, which was then associated with the argument `x`. We set `digits` to `0` this time so that `round` just returns a whole number, `4`. 

The important thing to realise is that the expression(s) on the right hand side of the `=` can be anything you like. This third example essentially equivalent to the last one:
```{r}
myvar <- 2.3 + 1.4
round(x = myvar, digits = 0)
```
This time we created a new variable called `myvar` and then supplied this as the value of the `x` argument. When we call the `round` function like this, the R interpreter spots the fact that something on the right hand side of an `=` is a variable and associates the value of this variable with `x` argument. As long as we have actually defined the numeric variable `myvar` at some point we can use it as the value of an argument. 

Keeping in mind what you have just learned, take a careful look at this example:
```{r}
x <- 0
round(x = 3.7, digits = x)
```
What is going on here? The key to understanding this is to realise that the symbol `x` is used in two different ways here. When it appears on the left hand side of the `=` it represents an argument name. When it appears on the right hand side it is treated as a variable name, which must have a value associated with it for the above to be valid. This is admittedly a slightly confusing way to use this function, but it is perfectly valid. The message here is that what matters is where things appear relative to the `=`, not the symbols used to represent them.

We said at the beginning of this section that a function may optionally __return__ a value to us when they finish complete their task. That word "return" is just jargon that refers to the process by which a function outputs a value. If you use a function at the Console this will be the value printed at the end. We can use this value in other ways too. For example, there is nothing to stop you combining function calls with the arithmetic operations:
```{r}
2 * round(x = 2.64, digits = 0)
```
Here the The R interpreter first evaluates the function call, and then multiplies the value it returns by 2. As you would expect, if we want to reuse this value we have to assign the result of function call, for example:
```{r}
roundnum <- 2 * round(x = 2.64, digits = 0)
```
Using a function with ` <- ` is really no different from the examples using multiple arithmetic operations in the last topic. The R interpreter starts on the right hand side of the ` <- `, evaluates the function call there, and only then assigns the value to `roundnum`.

## Functions do not have "side effects"

There is one more idea about functions and their arguments that you really need to understand in order to avoid confusing yourself later on in this course. It relates to how functions modify their arguments, or more accurately, how they __do not__ modify their arguments. Take a look at this example:
```{r}
myvar <- 3.7
round(x = myvar, digits = 0)
myvar
```
We created a variable `myvar` with the value 3.7, rounded this to a whole number with `round`, and then printed the value of `myvar`. Notice that __the value of `myvar` has not changed__ after using it as an argument to `round`. This is important. R functions typically do not alter the values of their arguments. Again, we say "typically" because there are ways to alter this behaviour if we really want to (yes, R is a very flexible language), but we will never ever do this. The standard behaviour---that functions do not alter their arguments---is what is meant by the phrase "functions do not have side effects".

If we had meant to round the value of `myvar` so that we can use this new value later on, we have to assign the result of function evaluation, like this:
```{r}
myvar <- 3.7
myvar <- round(x = myvar, digits = 0)
```
In this example, we just overwrote the old value, but we could just as easily have created a new variable. The reason this is worth pointing out is that new users sometimes assume certain types of functions will alter their arguments. Specifically, when working with functions manipulate something called a `data.frame`, there is a tendency to assume that the function changes the `data.frame` argument. It will not. If you want to make use of the changes, rather than just see them printed to the Console, you need to assign the results. You can do this by creating a new variable or overwriting the old one. You will gain first hand experience of this in the Data Wrangling block.

Remember, functions do not have side effects! Some of you will forget this and it will create all kinds of headaches. Don't be that person.

## Combining functions {#combining-functions}

Up until now we have not tried to do anything very complicated in our examples. Using R to actually get useful work almost always involves multiple steps, very often facilitated a number of different functions. There is more than one way to do this. Here is a simple example that takes an approach you should already understand:
```{r}
myvar <- sqrt(x = 10)
round(x = myvar, digits = 0)
```
Hopefully you can see what happened here. We calculated the square root of the number 10 and assigned the result to `myvar`, then we rounded this to a whole number and printed the result to the Console. So one way to use a series of functions in sequence is to assign a name to the result at each step and use this as an argument to the function in the next step.

Here is another way to replicate the calculation in the previous example:
```{r}
round(x = sqrt(x = 10), digits = 0)
```
The technical name for this is __function composition__ (you might recognise that phrase from secondary school mathematics). Another way of referring to this kind of expression is as a __nested function__ call: we say that the `sqrt` function is nested inside the `round` function. The way you should read these constructs is __from the inside out__. The `sqrt(x = 10)` expression is on the right hand side of an `=` symbol, so this is evaluated first, the result is associated with the `x` argument of the `round` function, and only then does the `round` function do its job.

There aren't really any new ideas here. We have already seen that the R interpreter evaluates whatever is on the right hand side of the `=` symbol first before associating the resulting value with the appropriate argument name. However, new users are often confused by nested function calls, so we want you to see them in action. There is nothing to stop us using multiple levels of nesting either. Take a look at this example:
```{r}
round(x = sqrt(x = abs(x = -10)), digits = 0)
```
The `abs` function takes the absolute value of a number, i.e. removes the `-` sign if it is there. Remember, read nested calls from the inside out. In this example, first we took the absolute value of -10, then we took the square root of the resulting number (10), and then we rounded this to a whole number.

Nested function calls are useful because they make our R code less verbose (we have to write less), but this comes at the cost of reduced readability. Experienced users are used to nesting so they don't mind it, but we leave it to you to decide whether to use it much. Though we aim to keep function nesting to a minimum in this course, you will occasionally have to work with the nesting construct so you should try to understand it even if you don't like using it. We will also see a much-easier-to-read method for applying a series of functions in the Data Wrangling block. 

## Specifying function arguments {#function-arguments}

We have only been working with functions that carry out mathematical calculations with numbers so far. We will see many more in this course as it unfolds. Some functions are designed to extract information about functions for us. For example, take a look at the `args` function:
```{r}
args(name = round)
```
You might be able to see what `args` does: it prints a summary of the main arguments of a function to the Console (it doesn't always print all the available arguments though). What can we learn from the summary of the `round` arguments? Notice that the first argument, `x`, is shown without an associated value, whereas the `digits` part of the summary is printed as `digits = 0`. **The significance of this is that `digits` has a default value**. This means that we can leave out `digits` when using the round function:
```{r}
round(x = 3.7)
```
This is obviously the same result as we would get using `round(x = 3.7, digits = 0)`. This is a very useful feature of R, as it allows us keep our R code concise. Some functions take a large number of arguments, many of which are defined with sensible defaults. Unless we need to change these default arguments, we can just ignore them when we call such functions. The `x` argument of `round` does not have a default, which means we have to supply a value. This is sensible, as the whole purpose of `round` is to round any number we give it.

There is another way to simplify our use of functions. Take a look at this example:
```{r}
round(3.72, digits = 1)
```
What does this demonstrate? We do not have to specify argument names, i.e. there is no need to specify argument names. In the absence of an argument name the R interpreter uses the position of the supplied argument to work out which name to associate it with. In this example we left out the name of the argument at position 1. This is where `x` belongs, so we end up rounding 3.71 to 1 decimal place. R is even more flexible than this, as it carries out partial matching on argument names:
```{r}
round(3.72, dig = 1)
```
This also works because R can unambiguously match the argument I named `dig` to `digits`. Take note, if there were another argument to `round` that started with the letters `dig` this would have caused an error. You need to know your function arguments if you want to rely of partial matching.


```{block, type="warning"}
#### Be careful with your arguments

Here is some advice. Do not rely on partial matching of function names. It just leads to confusion and the odd error. If you use it a lot you end up forgetting the true name of arguments, and if you abbreviate too much you create name matching conflicts. For example, if a function has arguments `arg1` and `arg2` and you use the partial name `a` for an argument, there is no way to know which argument you meant. We are pointing out partial matching so that you are aware of the behaviour. It is not worth the hassle of getting it wrong just to save on a little typing, so do not use it.

What about position matching?  This can also cause problems if we're not paying attention. For example, if you forget the order of the arguments to a function and then place your arguments in the wrong place, you will either generate an error or produce a nonsensical result. It is nice not to have to type out the `name = value` construct all the time though, so our advice is to rely positional matching only for the first argument. This is a common convention in R, and it makes sense because it is often obvious what kind of information or data the first argument should carry, so the its name is redundant.
```

<!--chapter:end:1_04_functions.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Numeric vectors

## Introduction 

The term "data structure" computer science jargon for a particular way of organising data on our computers, so that it can be accessed easily and efficiently. Computer languages use many different kinds of data structures, but fortunately, we only need to learn about a couple of relatively simple ones to use R for data analysis. In fact, in this book only two kinds of data structure really matter: "vectors" and "data frames". We'll learn how to work with data frames in the next section of the book. 

The next three chapters will consider vectors. This chapter has two goals. First, we want to learn the basics of how to work with vectors. For example, we'll see how "vectorised operations" may be used to express a repeated calculation. Second, we'll learn how to construct and use __numeric vectors__ to perform various calculations. Keep in mind that although we're going to focus on numeric vectors, many of the principles we learn here can be applied to the other kinds of vectors considered later.

## Atomic vectors

A vector is a 1-dimensional object that contains a set of data values, which are accessible by their position: position 1, position 2, position 3, and so one. When people talk about vectors in R they're often referring to __atomic vectors__^[The other common vector is called a "list". Lists are very useful but we won't cover them in this book]. An atomic vector is the simplest kind of data structure in R. There are a few different kinds of atomic vector, but the defining feature of each one is that it can only contain data of one type. An atomic vector might contain all integers (e.g. 2, 4, 6, ...) or all characters (e.g. "A", "B", "C"), but it can't mix and match integers and characters (e.g. "A", 2, "C", 5).

The word "atomic" in the name refers to the fact that an atomic vector can't be broken down into anything simpler---they are the simplest kind of data structure R knows about. Even when working with a single number we're actually dealing with an atomic vector. It just happens to be of length one. Here's the very first expression we evaluated in the first chapter:
```{r}
1 + 1
```
Look at the output. What is that `[1]` at the beginning? We ignored it before because we weren't in a position to understand its significance. The `[1]` is a clue that the output resulting from `1 + 1` is a atomic vector. We can verify this with the `is.vector` and `is.atomic` functions:
```{r}
x <- 1 + 1
# what value is associated with x?
x
# is it a vector?
is.vector(x)
# is it atomic?
is.atomic(x)
```
This little exercise demonstrates an important point about R. Atomic vectors really are the simplest kind of data structure in R. Unlike many other languages there is simply no way to represent just a number. Instead, a single number must be stored as a vector of length one^[The same is true for things like sets of characters (`"dog"`, `"cat"`, `"fish"`, ...) and logical values (`TRUE` or `FALSE`) discussed in the next two chapters.].

## Numeric vectors {#intro-vectors}

A lot of work in R involves __numeric vectors__. After all, data analysis is all about numbers. Here's a simple way to construct a numeric vector:
```{r}
numeric(length = 50)
```
What happened? We made a numeric vector with 50 __elements__, each of which is the number 0. The word "element" is used to reference any object (a number in this case) that resides at a particular position in a vector. 

When we create a vector but don't assign it to a name using ` <- ` R just prints it to the Console for us. Notice what happens when the vector is printed to the screen. Since the length-50 vector can't fit on one line, it was printed over two. At the beginning of each line there is a `[X]`: the `X` is a number that describes the position of the element shown at the beginning of a particular line.

```{block, type='info'}
#### Different kinds of numbers

Roughly speaking, R stores numbers in two different ways depending of whether they are whole numbers ("integers") or numbers containing decimal points ("doubles" -- don't ask). We're not going to worry about this distinction. Most of the time the distinction is fairly invisible to users so it is easier to just think in terms of numeric vectors. We can mix and match integers and doubles in R without having to worry too much about R is storing the numbers.
```

If we need to check that we really have made a numeric vector we can use the `is.numeric` function to do this:
```{r}
# let's create a variable that is a numeric vector 
numvec <- numeric(length = 50)
# check it really is a numeric vector
is.numeric(numvec)
```
This returns `TRUE` as expected. A value of `FALSE` would imply that `numvec` is some other kind of object. This may not look like the most useful function in the world, but sometimes we need functions like `is.numeric` to understand what R is doing or root out mistakes in our scripts.

Keep in mind that when we print a numeric vector to Console R only prints the elements to 7 significant figures by default. We can see this by printing the built in constant `pi` to the Console:
```{r}
pi
```
The actual value stored in `pi` is actually much more precise than this. We can see this by printing `pi` again using the `print` function: 
```{r}
print(pi, digits = 16)
```

## Constructing numeric vectors

We just saw how to use the `numeric` function to make a numeric vector of zeros. The size of the vector is controlled by the `length` argument---we used `length = 50` above to make a vector with 50 elements. This is arguably not a particularly useful skill, as we usually need to work vectors of particular values (not just 0). A very useful function for creating custom vectors is the `c` function. Take a look at this example:
```{r}
c(1.1, 2.3, 4.0, 5.7)
```
The "c" in the function name stands for "combine". The `c` function takes a variable number of arguments, each of which must be a vector of some kind, and combines these into a single, new vector. We supplied the `c` function with four arguments, each of which was a vector of length 1 (remember: a single number is treated as a length-one vector). The `c` function combines these to generate a vector of length 4. Simple. Now look at this example:
```{r}
vec1 <- c(1.1, 2.3)
vec2 <- c(4.0, 5.7, 3.6)
c(vec1, vec2)
```
This shows that we can use the `c` function to concatenate ("stick together") two or more vectors, even if they are not of length 1. We combined a length-2 vector with a length-3 vector to produce a new length-5 vector.

Notice that we did not have to name the arguments in those two examples---there were no `=` involved. The `c` function is an example of one of those flexible functions that breaks the simple rules of thumb for using arguments that we set out earlier: it can take a variable number of arguments, and these arguments do not have predefined names. This behaviour is  necessary if you think about how `c` has to work: in order to be useful it needs to be flexible enough to take any combination of arguments.

```{block, type="info"}
#### Finding out about a vector R

Sometimes it is useful to be able to find out a little extra information about a vector you are working with, especially if it is very large. Three functions that can extract some useful information about a vector for us are `length`, `head` and `tail`. Using a variety of different vectors, experiment with these to find out what they do. Make sure you use vectors that aren't too short (e.g. with a length of at least 10). Hint: `head` and `tail` can be used with a second argument, `n`. 
```

## Named vectors

What happens if we name the arguments to `c` when constructing a vector? Take a look at this:
```{r}
namedv <- c(a = 1, b = 2, c = 3)
namedv
```
What happened here is that the argument names were used to define the names of elements in the vector we made. The resulting vector is still a 1-dimensional data structure. When it is printed to the Console the value of each element is printed, along with the associated name above it. We can extract the names from a named vector using the `names` function:
```{r}
names(namedv)
```
Being able to name the elements of a vector is very useful because it enables us to more easily identify relevant information and extract the bits we need---we'll see how this works in the next chapter. 

## Generating sequences of numbers

The main limitation of the `c` function is that we have to manually construct vectors from their elements. This isn't very practical if we need to construct very long vectors of numeric values. There are various functions that can help with this kind of thing though. These are useful when the elements of the target vector need to follow a sequence or repeating pattern. This may not appear all that useful at first, but repeating sequences are used a lot in R.

### Generating sequences of numbers

The `seq` function allows us to generate sequences of numbers. It needs at least two arguments, but there are several different ways to control the sequence produced by `seq`. The method used is determined by our choice of arguments: `from`, `to`, `by`, `length.out` and `along.with`. We don't need to use all of these though---setting 2-3 of these arguments will often work:

1. Using the `by` argument generates a sequence of numbers that increase or decrease by the requested step size:
```{r}
seq(from = 0, to = 12, by = 2)
```
This is fairly self-explanatory. The `seq` function constructed a numeric vector with elements that started at 0 and ended 12, with successive elements increasing in steps of 2. Be careful when using `seq` like this. If the `by` argument does not lead to a sequence that ends exactly on the value of `to` then that value won't appear in the vector. For example:
```{r}
seq(from = 0, to = 11, by = 2)
```
You can generate a descending sequence by using a negative `by` value, like this:
```{r}
seq(from = 12, to = 0, by = -2)
```

2. Using the `length.out` argument generates a sequence of numbers where the resulting vector has the length specified by `length.out`:
```{r}
seq(from = 0, to = 12, length.out = 6)
```
Using the `length.out` argument will always produce a sequence that starts and ends exactly on the values specified by `from` and `to` (if we need a descending sequence we just have to make sure `from` is larger than `to`).

3. Using the `along.with` argument allows us to use another vector to determine the length of the numeric sequence we want to produce:
```{r}
# make any any vector we like
my_vec <- c(1, 3, 7, 2, 4, 2)
# use it to make a sequence of the same length
seq(from = 0, to = 12, along.with = my_vec)
```
It doesn't matter what the elements of `myvec` are. The behaviour of `seq` is controlled by the length of `myvec` when we use `along.with`.

It's conventional to leave out the `from` and `to` argument names when using the `seq` function. For example, we could rewrite the first example above as:
```{r}
seq(0, 12, by = 2)
```
When we leave out the name of the third argument its value is position matched to the `by` argument:
```{r}
seq(0, 12, 2)
```
However, our advice is to explicitly name the `by` argument instead of relying on position matching, because this will remind you what you're doing and will stop you forgetting about the different control arguments.

If we do not specify values of either `by`, `length.out` and `along.with` when using `seq` the default behaviour is to assume we meant `by = 1`:
```{r}
seq(from = 1, to = 12)
```
Generating sequences of integers that go up or down in steps of 1 is something we do a lot in R. Because of this, there is a special operator to generate these simple sequences---the colon, `:`. For example, to produce the last sequence again we use:
```{r}
1:12
```
When we use the `:` operator the convention is to __not__ leave spaces either side of it.

### Generating repeated sequences of numbers

The `rep` function is designed to replicate the values inside a vector, i.e. it's short for "replicate". The first argument (called `x`) is the vector we want to replicate. There are two other arguments that control how this is done. The `times` argument specifies the number of times to replicate the whole vector:
```{r}
# make a simple sequence of integers
seqvec <- 1:4
seqvec
# now replicate *the whole vector* 3 times
rep(seqvec, times = 3)
```
All we did here was take a sequence of integers from 1 to 4 and replicate this end-to-end three times, resulting in a length-12 vector. Alternatively, we can use the `each` argument to replicate each element of a vector while retaining the original order:
```{r}
# make a simple sequence of integers
seqvec <- 1:4
seqvec
# now replicate *each element* vector 3 times
rep(seqvec, each = 3)
```
This example produced a similar vector to the previous one. It contains the same elements and has the same length, but now the order is different. All the 1's appear first, then the 2's, and so on. 

Predictably, we can also use both the `times` and `each` arguments together if we want to:
```{r}
seqvec <- 1:4
rep(seqvec, times = 3, each = 2)
```
The way to think about how this works is to imagine that you apply `rep` twice, first with `each = 2`, then with `times = 3` (or vice versa). We can achieve the same thing using nested function calls, though it is much uglier:
```{r}
seqvec <- 1:4
rep(rep(seqvec, each = 2), times = 3)
```

## Vectorised operations

All the simple arithmetic operators (e.g. `+` and `-`) and many mathematical functions are __vectorised__ in R . What this this means is that when we use a vectorised function it operates on vectors on an element-by-element basis. Take a look at this example to see what we mean by this:
```{r}
# make a simple sequence
x <- 1:10
x
# make another simple sequence *of the same length*
y <- seq(0.1, 1, length = 10)
y
# add them
x + y
```
We constructed two length-10 numeric vectors, called `x` and `y`, where `x` is a sequence from 1 to 10 and `y` is a sequence from 0.1 to 1. When R evaluates the expression `x + y` it does this by adding the first element of `x` to the first element of `y`, the second element of `x` to the second element of `y`, and so on, working through all 10 elements of `x` and `y`.

Vectorisation is also implemented in the standard mathematical functions. For example, our friend the `round` function will round each element of a numeric vector:
```{r}
# make a simple sequence of non-integer values
my_nums <- seq(0, 1, length = 13)
my_nums
# now round the values
round(my_nums, digits = 2)
```
The same behaviour is seen with other mathematical functions like `sin`, `cos`, `exp`, and `log`. Each of these will apply the relevant function to each element of a numeric vector. 

Not all functions are vectorised. For example, the `sum` function takes a vector of numbers and adds them up:
```{r}
sum(my_nums)
```
Although `sum` obviously works on a numeric vector it is not "vectorised" in the sense that it works element-by-element to return an output vector of the same length as its main argument.

Many functions apply the vectorisation principle to more than one argument. Take a look at this example to see what we mean by this:
```{r}
# make a repeated set of non-integer values
my_nums <- rep(2 / 7, times = 6)
my_nums
# round each one to a different number of decimal places
round(my_nums, digits = 1:6)
```
We constructed a length 6 vector containing the number 2/7 (~ 0.285714) and then used the `round` function to round each element to a different number of decimal places. The first element was rounded to 1 decimal place, the second to two decimal places, and so on. We get this behaviour because instead of using a single number for the `digits` argument, we used a vector that is an integer sequence from 1 to 6.

```{block, type="info"}
#### Vectorisation is not the norm

R's vectorised behaviour may seem like the "obvious" thing to do, but most computer languages do not work like this. In other languages we typically have to write a much more complicated expression to do something so simple. This is one of the reasons R is such a data analysis language: vectorisation allows us to express repetitious calculations in a simple, intuitive way. This behaviour can save us a lot of time. However, not every function treats its arguments in a vectorised way, so we always need to check (most easily, by experimenting) whether this behaviour is available before relying on it.
```

<!--chapter:end:1_05_numeric_vectors.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Other kinds of vectors

## Introduction {#other-vectors}

The data we collect and analyse are often in the form of numbers, so it comes as no surprise that we work with numeric vectors a lot in R. Nonetheless, we also sometimes need to represent other kinds of vectors, either to represent different types of data, or to help us manipulate our data. This chapter introduces two new types of atomic vector to help us do this: character vectors and logical vectors.

## Character vectors

The elements of __character vectors__ are what are known as a "character string" (or "string" if we are feeling lazy). The term "character string" refers a sequence of characters, such as "Treatment 1", "University of Sheffield", "Population Density". A character vector is an atomic vector that stores an ordered collection of one or more character strings.

If we want to construct a character vector in R we have to place double (`"`) or single (`'`) quotation marks around the characters. For example, we can print the name "Dylan" to the Console like this:
```{r}
"Dylan"
```
Notice the `[1]`. This shows that what we just printed is an atomic vector of some kind. We know it's a character vector because the output is printed with double quotes around the value. We often need to make simple character vectors containing only one value---for example, to set the values of arguments to a function. 

The quotation marks are not optional---they tell R we want to treat whatever is inside them as a literal value. The quoting is important. If we try to do the same thing as above without the quotes we end up with an error:
```{r, error=TRUE}
Dylan
```
What happened? When the interpreter sees the word `Dylan` without quotes it assumes that this must be the name of a variable, so it goes in search of it in the global environment. We haven't made a variable called Dylan, so there is no way to evaluate the expression and R spits out an error to let us know there's a problem.

Longer character vectors are typically constructed to represent data of some kind. The `c` function is often a good starting point for this kind of thing:
```{r}
# make a length-3 character vector
my_name <- c("Dylan", "Zachary", "Childs")
my_name
```
Here we made a length-3 character vector, with elements corresponding to a first name, middle name, and last name. If we want to extract one or more elements from a character vector by their position  

Take note, this is __not__ equivalent to the above :
```{r}
my_name <- c("Dylan Zachary Childs")
my_name
```
The only element of this character vector is a single character string containing the first, middle and last name separated by spaces. We didn't need to use the the `c` function here because we were only ever working with a length-1 character vector. i.e. we could have typed `"Dylan Zachary Childs"` and we would have ended up with exactly the same text printed at the Console.

We can construct more complicated, repeating character vectors with `rep`. This works on character vectors in exactly the same way as it does on numeric vectors:
```{r}
c_vec <- c("Dylan", "Zachary", "Childs")
rep(c_vec, each = 2, times = 3)
```
Each element was replicated twice (`each = 2`), and then the whole vector was replicated three times (`times = 3`), end to end. 

What about the `seq` function? Hopefully it is fairly obvious that we can't use this function to build a character vector. The `seq` function is designed to make sequences of numbers, from a starting value, to another. The notion of a sequence of character strings -- for example, from `"Dylan"` to `"Childs"` -- is meaningless.

## Logical vectors

The elements of __logical vectors__ only take two values: `TRUE` or `FALSE`. Don't let the simplicity of logical vectors fool you---they're very useful. As with other kinds of atomic  vectors the `c` and `rep` functions can be used to construct a logical vector:
```{r}
l_vec <- c(TRUE, FALSE)
rep(l_vec, times = 2)
```
Hopefully nothing about that output is surprising by this point.

So why are logical vectors useful? Their allow us to represent the results of questions such as, "is x greater than y" or "is x equal to y". The results of such comparisons may then be used to carry out various kinds of subsetting operations based. 

Let's first look at how we use logical vectors to evaluate comparisons. Before we can do that though we need to introduce __relational operators__. These sound fancy, but they are very simple: we use relational operators to evaluate the relative value of vector elements. Six are available in R:

- `x < y `: is x less than y?
- `x > y `: is x greater than y?
- `x <= y`: is x less than or equal to y?
- `x >= y`: is x greater than or equal to y?
- `x == y`: is x equal to y?
- `x != y`: is x not equal to y?

The easiest way to understand how these work is to simply use them. We need a couple of numeric variables first:
```{r}
x <- 11:20
y <- seq(3, 30, by = 3)
x
y
```
Now, if we need to evaluate and represent a question like, "is x greater than than y", we can use either `<` or `>`:
```{r}
x > y
```
What do you notice about this simple example? The `x > y` expression produces a logical vector, with `TRUE` values associated with elements in `x` are less than `y`, and `FALSE` otherwise. In this example, x is less than y until we reach the value of 15 in each sequence. Notice that that relational operators are vectorised: the work on an element by element basis. They wouldn't be much use if this were not the case. 

What does the `==` operator do? It compares the elements of two vectors to determine if they are exactly equal:
```{r}
x == y
```
The output of this comparison is true only for one element, the number 15, which is at the 5^th^ position in both `x` and `y`. The `!=` operator is essentially the opposite of `==`. It identifies cases where two elements are not exactly equal. We could step through each of the different the other relational operators, but hopefully they are self-explanatory at this point (if not, experiment with them).

```{block, type="warning"}
#### `=` and `==` are not the same

If we want to test for equivalence between the elements of two vectors we must use double equals (`==`), not single equals (`=`). Forgetting to do this `==` instead of `=` is a very common source of mistakes. The `=` symbol already has a use in R---assigning name-value pairs---so it can't also be used to compare vectors because this would lead to ambiguity in our R scripts. Using `=` when you meant to use `==` is a very common mistake. If you make it, this will lead to all kinds of difficult-to-comprehend problems with your scripts. Try to remember the difference!
```


<!--chapter:end:1_06_more_vectors.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Extracting subsets of vectors

## Introduction {#other-vectors}

At the beginning of the last chapter we said that an atomic vector is a 1-dimensional object that contains an **ordered** collection of data values. Why is this view of a vector useful? It means that we can extract a subset of elements from a vector once we know their position in that vector. There are are two main ways to subset atomic vectors, both of which we'll cover in this chapter. Whatever the method we use, subsetting involves a pair opening and closing square brackets (`[` and `]`). These are always used together. 

## Subsetting by position 

We can use the `[` construct with a vector to subset its elements directly using their position. Take a look at this example:
```{r}
c_vec <- c(7.2, 3.6, 2.9)
c_vec[2]
```
The `c_vec` variable is a length 3 character vector, with elements corresponding to his first, middle and last name. In order to subset it an retain only the first element -- his first name -- we used the `[ ]` construct with the number 1 inside, placing `[1]` next to the name of the vector. Notice that we do not place a space anywhere in this construct. We could, but this is not conventional.

Remember, "the number 1" is in fact a numeric vector of length 1. This suggest we might be able to use longer vectors to extract more than one element: 
```{r}
# make a numeric sequence
my_vec <- seq(0, 0.5, by = 0.1)
my_vec
# make an indexing vector
i <- c(1, 3)
# extract a subset of values
my_vec[i]
```
We first constructed a numeric vector of length 2 called `index`, which has elements `1` and `3`. We then used this to extract his first and third value by placing `i` inside the `[ ]`. We didn't have to carry out the subsetting operation in two steps. This achieves the same result:
```{r}
my_vec[c(1, 3)]
```
Notice that when we subset a vector of a particular type, we get a vector of the same type back, e.g. subsetting a numeric vector produces another numeric vector.

We can also subset a vector by removing certain elements. We use the `-` operator to do this. Here's an example that produces the same result as the last example, but in a different way:
```{r}
my_vec[-c(2, 4, 5, 6)]
```
The `my_vec[-c(2, 4, 5, 6)]` expression indicates that we want all the elements of `c_vec` __except__ those that at position 2, 4, 5, and 6.

In the previous chapter we learned how use the `[` construct with a numeric vector of integer(s) to subset the elements of vector by their position. This works exactly the same way with character vectors:
```{r}
c_vec <- c("Dylan", "Zachary", "Childs")
c_vec[1]
```
The `c_vec` variable is a length 3 character vector, with elements corresponding to his first, middle and last name. We used the `[ ]` construct with the number 1 inside, to extract the first element (i.e. the first name). Longer vectors can be used to extract more than one element, and we can use negative numbers to remove elements: 
```{r}
# extract the first and third value
c_vec[c(1, 3)]
# drop the second value (equivalent)
c_vec[-2]
```

## Subsetting with logical operators

Subsetting vectors by position suffers from once major drawback---we have to know where the elements we want sit in the vector. A second way to subset a vector makes use of logical vectors alongside `[ ]`. This is usually done using two vectors of the same length: the focal vector we wish to subset, and a logical vector that specifies which elements to keep. Here is a very simple example:
```{r}
i <- c(TRUE, FALSE, TRUE)
c_vec[i]  
```
This should be fairly self-explanatory. The logical vector method of subsetting works element-by-element, and an element in `c_vec` is retained wherever the corresponding element in `i` contains a `TRUE`; otherwise it is discarded.

Why is this better that using position indexing? After all, using a vector of positions to subset a vector is much more direct. The reason is that we can use relational operators to help us select elements according to particular criteria. This is best illustrated with an example. We'll start by defining two vectors of the same length: 
```{r}
name <- c("cat", "dog", "wren", "pig", "owl")
name
type <- c("mammal", "mammal", "bird", "mammal", "bird")
type
```
The first, `name`, is a character vector containing the common names of a few animals. The second, `type`, is another character vector whose elements denote the type of animal, in this case, a bird or a mammal. The vectors are arranged such that the information is associated via the position of elements in each vector (cats and dogs are mammals, a wren is a bird, and so on).

Let's assume that we want to create a subset of `name` that only contains the names of mammals. We can do this by creating a logical vector from `type`, where the values are `TRUE` when an element is equal to `"mammal"` and `FALSE` otherwise. We know how to do this using the `==` operator: 
```{r}
i <- type == "mammal"
i
```
We stored the result in a variable called `i`. Now all we need to do is use with `i` inside the `[ ]` construct to subset `name`:
```{r}
name[i]
```
We did this the long way to understand the logic of subsetting vectors with logical operators. This is quite verbose though, and we usually combine the two steps into a single R expression:
```{r}
name[type == "mammal"]
```

We can use any of the relational operators to subset vectors like this. If we define a numeric variable that contains the mean mass (in grams) of each animal, we can use this to subset `names` according to the associated mean mass. For example, if we want a subset that contains only those animals where the mean mass is greater than 1kg we use: 
```{r}
mass <- c(2900, 9000, 10, 18000, 2000)
name[mass > 1000]
```
Just remember, this way of using information in one vector to create subsets of a second vector only works if the information in each is associated via the position of their respective elements. Keeping a bunch of different vectors organised like this is difficult and error prone. In the next block we'll learn how to use something called a data frame and the `dplyr` package to make working with a collection of related vectors much easier.

<!--chapter:end:1_07_subset_vectors.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Getting help

## Introduction {#console-help}

R has a comprehensive built-in help system. This system is orientated around the base R functions and packages. Every good package comes with a set of __help files__. At a minimum these should provide information about the individual package functions and summaries of the data included with the package. They sometimes give descriptions of how different parts of the package should be used, and if we're lucky, one or more "vignettes" that offer a practical demonstration of how to use a package. Other files are sometimes shipped with packages. For example, these might give an overview of the mathematical or computational theory a package relies on. We will not worry about these in this course. 

We may as well get something out of the way early on. The word "help" in the phrase "help file" is a bit of a misnomer. It is probably more accurate to say R has an extensive __documentation__ system. The reason we say this is that the majority help files are associated with functions, and these kinds of files are designed first and foremost to document how a particular function or group of functions are meant to be used. For example, they describe what kinds of arguments a function can take and what kind of objects it will return to us. Help files are also written in a very precise, painful-to-read manner. They contain a lot of jargon which can be hard to decipher unless you already know a lot about R or you have a computer science background.

The take-home message is that R help files are aimed more at experienced users than novices. Their primary purpose is to carefully document the different elements of a package, rather than explain how a particular function or the package as whole should be used to achieve a given end. That said, help files often contain useful examples, and many package authors do try to make our life easier by providing functional demonstrations of their package (those "vignettes" we mentioned above are a vehicle for doing this). It is very important to try to get to grips with the built in help system. It contains a great deal of useful information which you need to learn how to decipher in order to start using R effectively. The road to enlightenment is bumpy though.

## Browsing the help system

How do we access the help system? Help files are a little like mini web pages, which means we can navigate among them using hyperlinks. This makes it very easy to explore the help system. One way to begin browsing the help system uses the `help.start` function: 
```{r, eval=FALSE}
help.start() 
```
If you type this now at the Console you will see the __Package Index__ page open up in the __Help__ tab of the bottom right pane in RStudio. This lists all the packages currently installed on your computer. We can view all the help files associated with a package by clicking on the appropriate link. For example, the functions that come with the base installation of R have a help file associated with them -- click on the link to the R base package (`base`) to see these. Though you know about a few of these already, you will see __a lot__ of functions listed here. R is huge.

The packages that come with the base R installation and those that we install separately from base R have their own set of associated help files. These can be viewed by following the appropriate link on the __Package Index__ page. We will learn how to navigate these in a moment. Take note: it is up to the developer of a package to produce usable help files. Well-designed packages like __dplyr__ and __ggplot2__ have an extensive help system that covers almost everything the package can do. This isn't always the the case though, particularly with new or packages or packages that are not widely used. We will only ever use well-documented packages.

Notice that the help browser has Forward, Back, and Home buttons, just like a normal web browser. If you get lost in the mire of help pages you can always navigate backward until you get back to a familiar page. Annoyingly, the Home button does not take you to the same page as `help.start`. Click the home button now if you have not already done so. You will see three sections: 

1. The __Manuals__ section looks like it might be useful for novice users. Unfortunately, it is not. Even the "Introduction to R" manual is only helpful if you already have some programming experience, since it assumes you understand what terms like "data structure" and "data type" mean. It is worth reading this manual once you have gained a little more experience though. The others manuals. are more or less impenetrable unless you already know quite a bit about computing in general.

2. The __Reference__ section is a little more helpful. The "Packages" link just takes you to the same page opened by `help.start` so that you can browse help pages on a package-specific basis. The "Search Engine & Keywords" link takes you to a search engine page (no surprises there). You can use this to search for specific help pages, either by supplying a search term or by navigating through the different keywords. We will discuss the built-in search engine in the next subsection.

3. The __Miscellaneous Material__ section has a couple of potentially useful links. The "User Manuals" link lists any user manuals supplied by package authors. These tend to be aimed at more experienced users and the packages we will learn to use in this course do not provide them. However, it is worth knowing these exist as they are occasionally useful. The "Frequently Asked Questions" link is worth reviewing once you have gained a little experience of R, but again, most of the FAQs are a little difficult for novice users to fully understand.

## Searching for help files

If you spend a short amount of time browsing help files via `help.start` it will quickly become obvious that this way of searching for help is not very efficient. Quite often we know the name of the function we need to use and all we want to do is open its associated help file. We do this using the `help` function:
```{r, eval=FALSE}
help(topic = Trig)
```
If you run this simple example you should see RStudio open up the help file for the trigonometry topic in the __Help__ tab. This provides information about the various trigonometric functions such as `sin` or `cos`. We will learn how to make sense of help pages in the next subsection. For now we just need to understand how to use `help`.

The `help` function needs a minimum of one argument: the name of the topic or function of interest. When we use it like this the help function searches across packages, looking for a help file whose name gives __an exact match__ to the name we supplied. In this case, we opened the help file associated with the `Trig` topic. Most of the time we use the `help` function to find the help page for a specific function, rather than a general topic. This is fine if you can remember the name of the topic associated with different functions. Most of us cannot. Luckily, the help function will also match help pages by the name of the function(s) they cover:
```{r, eval=FALSE}
help(topic = sin)
```
Here we searched for help on the `sin` function. This is part of the `Trig` topic so `help(topic = sin)` brings up the same page as the `help(topic = Trig)`.

There are several arguments of `help` that we can set to alter its behaviour. We will just consider one of these. By default, the `help` function only searches for files associated with the base functions or with packages that we have loaded in the current session with the `library` function. If you wanted to search for help on the `mutate` function -- which is part of the `dplyr` package -- but you haven't run `library(dplyr)` yet this will not work:
```{r}
help(mutate)
```
Instead, you need tell `help` where to look by setting the `package` argument:
```{r, eval=FALSE}
help(mutate, package = dplyr)
```

You should try to start using `help` every time you get stuck because you cannot get a function to work. It doesn't matter how experienced an R user you become, you will occasionally forget how to use the odd function. It is for this reason that R has a built in shortcut for `help`. This is accessed via `?`. For example, instead of typing `help(topic = sin)` (or just `help(sin)`) at the Console, we can bring up the help page for the `sin` function by using `?` like this:
```{r, eval=FALSE}
?sin
```
This is just a convenient shortcut that does the same thing as `help`. The only difference is that `?` does not allow us to set arguments such as `package`.

## Navigating help files {#nav-help}

Navigating a typical help file is a little daunting at first. These files can be quite long and they contain a lot of jargon. The help files associated with functions -- the most common type -- have a consistent structure though. There are a number of distinct sections, whose order is always the same. Wrestling with a help file is much easier if you are at least clear about the purpose of each section. After the title, there are eight of these you need to know about:

1. __Description__  gives us a short overview of what the function is meant to be used for. If the help page covers a family of related functions it gives a collective overview of all the functions. You should always read this before diving into the rest of the help file.

2. __Usage__ shows how the function(s) are meant to be used. It lists each member of the family as well as their common arguments. The argument names are listed on their own if they have no default, or in name-value pairs, where the value gives the default used should we choose not to set it ourselves when we call the function.

3. __Arguments__ lists each of the allowed arguments, along with a short description of what they influence. This also tells us what what kind of data we are allowed to use with each argument, along with the allowable values (if this is relevant). You should always read this section.

4. __Details__ describes precisely how the function(s) behave, often in painful, jargon-laden detail. It is usually the longest and hardest-to-comprehend section but is worth reading as it flags up common "gotchas". You can sometimes get away with ignoring this section if the previous three are informative enough, but if you really want to understand a function you need to wade through this.

5. __Value__ explains kind of data structure or object a function returns to us when it finishes doing whatever it does. You can often guess what this will be from the type of function, but it is worth checking to see if your reasoning is correct. If it is not, you probably don't understand the function yet.

6. __References__ just lists the key reference(s) you should read if you really need to know the hows and whys of a function. You almost never need to read this. The one exception is if the function implements a particular statistical tool. In that case it might be sensible to go away and read the literature before trying to use it.

7. __See Also__ gives links to the help pages of related functions. These are usually functions that do something similar to the function of interest or are meant to be used in conjunction with it. You can often learn quite a bit about packages or related functions by following the links in this section.

8. __Examples__ provides one or more examples of how to use the function. These are stand-alone examples, so there is nothing to stop you running them. This is often the most useful section of all. Seeing a function in action is a very good way to cut through the jargon and start to understand how it works. 

## Vignettes and demos {#vignettes}

The Oxford English Dictionary defines a vignette as, "A brief evocative description, account, or episode." The purpose of a package vignette in R is to provide a relatively brief, practical account of one or more of its features. Not all packages come with vignettes, though many of the best thought out packages do. You can use the `vignette` function to view all the available vignettes in Rstudio. This will open up a tab that lists each vignette under their associated package name along with a brief description. A package will often have more than one vignette. If you just want to see the vignettes associated with a particular package, you should set the `package` argument. For example, to see the vignettes associated with __dplyr__ you would use:
```{r, eval=FALSE}
vignette(package = "dplyr")
```

Each vignette has a name (the "topic") and is available either as a PDF or HTML file (or both). We can view a particular vignette by passing the `vignette` function the `package` and `topic` arguments. For example, to view the "data_frames" vignette in the __`dplyr`__ package we would use: 
```{r, eval=FALSE}
vignette(topic = "data_frames", package = "dplyr")
```

The `vignette` function is fine, though it is usually more convenient to browse the list of vignettes inside a web browser. This allows you to open a particular vignette directly by clicking on its link, rather than working at the Console. We can use the `browseVignettes` function to do this:
```{r, eval=FALSE}
browseVignettes()
```
This will open a page in your browser showing the vignettes you can view. As you might expect by now, you can narrow your options to a specific package by setting the `package` argument.

In addition to vignettes, some packages also include one or more demos (i.e. demonstrations). Demos are a little like vignettes, but instead of just opening a file for you to read, the demo function can actually runs a demonstration R scripts for you. We use the `demo` function without any arguments to list the available demos:
```{r, eval=FALSE}
demo()
```
When we use the `demo` function like this it only lists the demos associated with packages that have been loaded in the current session (via `library`). If we want to see all the demos you can run you need to use the somewhat cryptic `demo(package = .packages(all.available = TRUE))`. 

In order to actually run a demo we use the `demo` function, setting the `topic` and `package` arguments. For example, to run the "colors" demo in the __grDevices__ package we would use:
```{r, echo=FALSE}
demo(colors, package = "grDevices", ask = FALSE)
```
This particular demo shows off some of the pre-defined colours we might use to customise the appearance of a plot. We've suppressed the output though because so much is produced.




<!--chapter:end:1_08_getting_help.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Packages

## The R package system {#package-system}

The R package system is probably the most important single factor driving increased adoption of R among quantitatively-minded scientists. Packages make it very easy to extend the basic capabilities of R. In [his book](http://r-pkgs.had.co.nz) about R packages Hadley Wickam says,

> Packages are the fundamental units of reproducible R code. They include reusable R functions, the documentation that describes how to use them, and sample data.

An R package is just a collection of folders and files in a standard, well-defined format. They bundle together together computer code, data, and documentation in a way that is easy to use and share with other users. The computer code might all be R code, but it can also include code written in other languages. Packages provide an R-friendly interface to use this "foreign" code without the need to understand how it works.

When you download the base R distribution it comes with quiet a few packages already installed. These are "mature" packages that implement widely used statistical and plotting functionality. These base R packages represent a very small subset of all the packages you can use with R though. The majority of packages are hosted on a network of web servers around the world collectively know as [CRAN](http://cran.r-project.org). This network -- which is known as a repository -- is the same one we used to download the base R distribution in the [Get up and running with R and RStudio] chapter. CRAN stands for the Comprehensive R Archive Network, pronounced either "see-ran" or "kran". CRAN is a fairly spartan web site, so it is easy to find your way around. 

If you now [navigate to CRAN](http://cran.r-project.org) you will see about a dozen links of the right hand side of the page. Under the _Software_ section there is link called [Packages](http://cran.r-project.org/web/packages/). Near the top of this page there is a link called [Table of available packages, sorted by name](http://cran.r-project.org/web/packages/available_packages_by_name.html). Following this link takes you to a very long list of all the packages hosted on CRAN -- the column on the left shows each package name, followed by a brief description of what the package does on the right. There are a huge number of packages here (6369 at the time of writing). It is worth spending a few minutes looking over this list to get a sense of the diversity of R packages.

## Task views

A big list of packages presented like this is overwhelming. Unless you already know the name of the package you want to investigate it is very hard to find anything useful this way. A more user-friendly view of many R packages can be found on the [Task Views](http://cran.r-project.org/web/views/) page. The link to this is on the left hand side, under the section labelled _CRAN_. If you navigate to the Task Views page now you will see of list of topics with a brief description. A Task View is basically a curated guide to the packages and functions that are useful for certain disciplines. 

The [Environmentrics](http://cran.r-project.org/web/views/Environmetrics.html) Task View maintained by Gavin Simpson contains information about using R to analyse ecological and environmental data. It is not surprising this Task View exists. Ecologists and environmental scientists are among the most enthusiastic R users. This view is a good place to start if you find yourself in need of a package to support a particular analysis in a future project. The [Experimental Design](http://cran.r-project.org/web/views/ExperimentalDesign.html), [Graphics](http://cran.r-project.org/web/views/Graphics.html), [Multivariate](http://cran.r-project.org/web/views/Multivariate.html), [Phylogenetics](http://cran.r-project.org/web/views/Phylogenetics.html), [Spatial](http://cran.r-project.org/web/views/Spatial.html), [Survival](http://cran.r-project.org/web/views/Survival.html) and [Time Series](http://cran.r-project.org/web/views/TimeSeries.html) Task Views alll contain some useful information for biologists and environmental scientists.

## Using packages {#use-packages}

Two things need to happen in order for you to use a package. First, you need to ensure that a copy of the folders and files that comprise the package are copied to an appropriate folder on your computer, called a library. This is called __installing__ the package. Second, we need to __load and attach__ the package for use in a particular R session. As usual, the word "session" in this context just refers to the time between when you start up R and close it down again.

Let's unpack what we just said, because for some reason the package system often confuses new users.

* If you do not have a copy of a package's folders and files in the right format and in the right place on your computer you cannot use it. This is probably fairly obvious to you. The process of making this copy is called __installing__ the package. We could install a package by going to the CRAN website, downloading the package and making use of various tools in R to install it. We will not use this approach because it is inefficient and error prone. Instead, we will use built-in R functions to grab the package from CRAN and install it for us, all in one step.

* You do not need to install the packages you plan to use every time you start a new R session. It is worth saying that again, __there is no need to install packages each time you open up R / RStudio__. Once you have a copy of the package on your hard drive it will remain there for you to use, unless you delete it or you install a version of R.

* Installing a package does nothing more than place a copy of the relevant files on your hard drive. If you want to use the functions or data that come with a package you need to make them available in your current R session. Unlike package installation this process has to be repeated every time you restart R.

Take note: every time you install a new major version of R (not RStudio) you will need to reinstall any packages you plan to use. This is because the R installer will not copy installed packages to the new version of R.

### Viewing installed packages

We sometimes need to check whether a package is currently installed on our computer. Use the `find.package` function to do this:
```{r}
find.package("MASS")
```
This prints a file path showing where the package is located, or returns an error if the package does not exist. If you understand file paths, great. If you do not, then the take home message is that `find.package` will only return some location information if a package has been installed. The is also a function called `installed.packages` that returns something called a data frame object (these are discussed in the next block) containing a lot of information about the packages installed on your computer.

As you might expect, RStudio provides a more intuitive way to see which packages are installed on your computer. The __Packages__ tab in the top right pane of RStudio shows the name of every installed package, a brief description (the same one seen on CRAN) and a version number. We can also manage our packages from this tab, as we are about to find out.

### Installing and updating packages

R packages can be installed in a number of different ways. For example, they can be installed from a local file on your computer, from the CRAN repository, or from a different kind of online repository called Github. Although CRAN alternatives are becoming more popular, in this course we will only worry about installing packages that live on CRAN.

In order to install a package from an online repository like CRAN we have to first download the package files, possibly uncompress them (like you would a ZIP file), and move them to the correct location. Fortunately, all of this can be done at the Console using a single function, `install.packages`. For example, if we want to install the __fortunes__ package, we use:
```{r, message = TRUE, eval = FALSE}
install.packages("fortunes")
```
The quotes are necessary by the way. Try this on your own computer. If everything is working -- e.g. you have an active internet connection, you used a valid package name, and so on -- R will briefly pause while it communicates with the CRAN servers, you should see some red text and then you will be returned to the prompt. The red text is just letting us know what R is up to. As long as this text does not include an error, there is no need to worry about it.

There is nothing to stop us using `install.packages` to install more than one package at a time. We are going to use __dplyr__ and __ggplot2__ in the next two blocks. Since neither of these is part of the base R distribution, we need to download and install them from CRAN. Here is one way to do this:  
```{r, eval = FALSE}
pckg.names <- c("dplyr","ggplot2")
install.packages(pckg.names)
```
Simple. If you are working on your own computer you should do this now so that they are ready to use later in the course.

There are a couple of things to keep in mind when you install packages. First, package names are case sensitive, like variable names. For example, __fortunes__ is not the same as __Fortunes__. Quite often when you fail to install a package which you know exists it is because you used the wrong case somewhere in its name. The other aspect of packages you keep to know about is related to __dependencies__: some packages rely on other packages in order to work properly. By default `install.packages` will install these dependencies for us, so we do not usually have to worry too much about them. However, do not be surprised if using the `install.packages` function installs more than one package when you only specified one package name.

If you prefer not to work at the Console to install packages RStudio gives you a way of interacting with `install.packages` via the GUI. The __Packages__ tab has an "Install"" button at the top right. Clicking on this brings up a small window with three main fields: "Install from", "Packages", and "Install to Library". We only need to work with the "Packages" field -- the other two can be left at their defaults. When you start typing in the first few letters of a package name (e.g. __dplyr__) RStudio will provide a list of available packages that match this. After we select the one we want and click the "Install" button RStudio invokes `install.packages` with the appropriate arguments at the Console for us.

### Loading and attaching packages

Once we have installed a package or two we will probably want to actually use them. Two things have to happen to access a package's facilities: the package has to be loaded into memory, and then it has to attached to something called a search path so that R can find it. It is beyond the scope of the course to get in to hows and whys of this. Luckily for us loading and attaching a package is done with a single function called `library`, so there is no need to worry about the details. Library works exactly as you would expect it to. If we want to start using the `fortunes` package -- which we just installed above -- all we need is:
```{r}
library(fortunes)
```
Notice that library does not need its main argument to be quoted; `library("fortunes")` does the same thing though.

Nothing much happens if everything is working as it should. R just returns us to the prompt without printing anything to the Console. The difference is that now we can use the functions that __fortunes__ provides. As it turns out, there is only one:
```{r, eval=FALSE}
fortune()
```
```{r, eval=TRUE, echo=FALSE}
fortune("Cryer")
```
The __fortunes__ package is either very useful or utterly pointless, depending on your perspective. It dispenses quotes from various R experts delivered through the R mailing list over the years. 

As usual, if you really do not like using the command line RStudio can help you out. There is a small button next to each package listed in the __Packages__ tab. Packages that have been loaded and attached have a blue check box next to them, whereas this is absent from those that have not. Clicking on an empty check box will load up the package. Try this. Notice that all it does is invoke `library` with the appropriate arguments for us (RStudio explicitly sets the `lib.loc` argument, whereas above we just relied on the default value).

```{block, type="warning"}
#### Never use `install.packages` in scripts 

Because installing a package is a "do once" operation, it is almost never a good idea to place `install.packages` in a typical R script. A script may be run 100s of times as we develop an analysis. Installing a package is quite time consuming, so we don't really want to do it every time we run our analysis. As long as the package has been installed at some point in the past it is ready to be used and the script will work fine without reinstalling it.

On the other hand, if a script makes use of a package we do need to load and attach that package before we can use it, i.e. loading and attaching a package is a "do every time" operation. This means that it is a good idea to include `library` in a script that needs to use a package. We can use library anywhere, but typically the `library(<package name>)` expressions live at the very beginning of a script so that everything is ready to use later on.
```

### An analogy

We noted above that the package system often confuses new users. The reason for this stems from the fact that they aren't really clear about what the `install.packages` and `library` functions are doing. One way to think about these is by analogy with smartphone "Apps". Think of an R package as being analogous to a smartphone App--- a package effectively extends what R can do, just as an App extends what your phone can do.

When you want to try out a new App you have to first download it from an App store and install it on your phone. Once it has been downloaded, an App lives permanently on your phone (unless you delete it!) and can be used whenever you need it. Downloading and installing an App is something you only have to do once. Packages are no different. When you want to use an R package you also have to make sure it is first installed on your computer. This is effectively what `install.packages` does: it grabs the package from CRAN (the "App store") and installs it on your computer. Installing a package is a "do once" operation. Once you have installed it, you don't need to install a package again each time you restart R. The package is sat on your hard drive ready to be used.

(There are obvious exceptions to the "do once" rule. If you have recently updated R you will need to reinstall all the packages you need to use. This is a bit like buying a new phone. Similarly, you may need to occasionally reinstall a package to get hold of a latest version.)

In order to actually use an App which has been installed on your phone you have to open it up by tapping on its icon. You obviously have to do this every time you want to use the App. The package equivalent of opening a smartphone App is the load and attach operation. This is what `library` does. It makes a package available for use in a particular session. You have to use `library` to load the package every time you start a new R session if you plan to access the functions in that package. So loading and attaching a package via `library` is a "do every time" operation. 


<!--chapter:end:1_09_using_packages.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# (PART) Data Wrangling {-} 


<!--chapter:end:2_00.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Data frames

## Introduction

We learned in the [A quick introduction to R] chapter that the word "variable" is used as short hand for any kind of named object. For example, we can make a variable called `num_vec` that refers to a simple numeric vector using:
```{r}
num_vec <- 1:10
```
When a computer scientist talks about variables they're usually referring to these sorts of name-value associations. However, the word "variable"" has a second, more abstract meaning in the world data analysis and statistics: it refers to anything we can control or measure. For example, if our data comes from an experiment, the data will typically involve variables whose values describe the experimental conditions (e.g. "control plots" vs. "fertiliser plots") and the quantities we chose to measure (e.g. species biomass and diversity). 

These kinds of abstract variables are often called "statistical variables". Statistical variables can be further broken down into a range of different types. We'll discuss these later in the book. The reason we're pointing out the dual meaning of the word "variable" now is because we need to be able to work with both interpretations. The dual meaning is confusing at first, but both meanings are in such widespread use that we just have to get used to them. We'll try to minimise confusion by using the phrase "statistical variable" when we are referring to data, rather than R objects.

We're introducing these ideas now because we're going to consider a new type of data object in R: the __data frame__. Real world data analysis involves collections of data ("data sets") that involve several related statistical variables. We've seen that an atomic vector can only be used to store one type of data such as a collection of numbers. This means a vector can be used to store a single statistical variable, How should we keep a large collection of variables organised? We could work with them separately but this is very error prone. Ideally, we need a way to keep related variables together. This is the problem that __data frames__ and are designed to manage.

## Data frames {#data-frames-intro}

Data frames are one of those R features that mark it out as a particularly good environment for data analysis. You can think of a data frame as table-like objects with rows and columns. They collect together different statistical variables, storing each of them as a different column. Related observations are all found in the same row. This will make more sense in a moment. Let's consider the columns first.

Each column is a vector of some kind. These are usually simple vectors containing numbers or character strings, though it is also possible to include more complicated vectors inside data frames. We'll only work with data frames made up of relatively simple vectors in this book. The key constraint that a data frame applies is that each vector must have the same length. This is what gives a data frame it table-like structure. 

The simplest way to get a feel for data frames is to make one. Data frames are usually constructed by reading some external data into R, but for the purposes of learning about them it is better to build one from from its component parts. We'll make some artificial data describing a hypothetical experiment to do this. Imagine that we've conducted a small experiment to examine biomass and community diversity in six field plots. Three plots were subjected to fertiliser enrichment. The other three plots act as experimental controls. We could store the data describing this experiment in three vectors: 

-   `trt` (short for "treatment") shows which experimental manipulation was used.

-   `bms` (short for "biomass") shows the total biomass measured at the end of the experiment.

-   `div` (short for "diversity") shows the number of species present at the end of the experiment.

Here's some R code to generate these three vectors (it doesn't matter what the actual values are, they're made up):
```{r}
trt <- rep(c("Control","Fertilser"), each = 3) 
bms <- c(284, 328, 291, 956, 954, 685)
div <- c(8, 12, 11, 8, 4, 5)
```
```{r}
trt
bms
div
```
Notice that the information about different observations are linked by their positions in these vectors. For example, the third control plot had a biomass of '291' and a species diversity '11'.

We can use the `data.frame` function to construct a data frame from one or more vectors. To build a data frame from the three vectors we created and print these to the Console, we use:
```{r}
experim.data <- data.frame(trt, bms, div)
experim.data
```
Notice what happens when we print the data frame: it is displayed as though it has rows and columns. That's what we meant when we said a data frame is a table-like structure. The `data.frame` function takes a variable number of arguments. We used the `trt`, `bms` and `div` vectors as arguments, resulting in a data frame with three columns. Each of these vectors has 6 elements, so the resulting data frame has 6 rows. The names of the vectors were used to name its columns. The rows do not have names, but they are numbered to reflect their position.

The words `trt`, `bms` and `div` are not very informative. If we prefer to work with more informative column names---this is always a good idea---then we have to name the `data.frame` arguments:
```{r}
experim.data <- data.frame(Treatment = trt, Biomass = bms, Diversity = div)
experim.data
```
The new data frame contains the same data as the previous one but now the column names correspond to the names we chose. These names are better because they describe each variable using a human-readable word. 

```{block, type="warning"}
#### Don't bother with row names

We can also name the rows of a data frame using the `row.names` argument of the `data.frame` function. We won't bother to show an example of this though. Why? We can't easily work with the information in row names so there's not much point adding it. If we need to include row-specific data in a data frame it's best to include an additional variable, i.e. an extra column.
```

## Exploring data frames

The first things we should do when presented with a new data set is explore its structure to understand what we're dealing with. This is easy when the data is stored in a data frame. If the data set is reasonably small we can just print it to the Console. This is not very practical for even moderate-sized data sets though. The `head` and `tail` functions extract the first and last few rows of a data set, so these can be used to print part of a data set. The `n` argument controls the number of rows printed:
```{r}
head(experim.data, n = 3)
tail(experim.data, n = 3)
```

The `View` function can be used to visualise the whole data set in a spreadsheet like view:
```{r, eval=FALSE}
View(experim.data)
```
This shows the rows and columns of the data frame argument in a table- or spreadsheet-like format. When we run this in RStudio a new tab opens up with the `experim.data` data inside it. 

```{block, type=""}
#### `View` only displays the data

The `View` function is designed to allow us to display the data in a data frame as a table of rows and columns. We can't change the data in any way with the `View` function. We can reorder the way the data are presented, but keep in mind that this won't alter the underlying data. 
```

There are quite a few different R functions that will extract information about a data frame. The `nrow` and `ncol` functions return the number of rows and columns, respectively:
```{r}
nrow(experim.data)
ncol(experim.data)
```
The `names` function is used to extract the column names from a data frame:
```{r}
colnames(experim.data)
```
The `experim.data` data frame has three columns, so `names` returns a character vector of length three, where each element corresponds to a column name. There is also a `rownames` function if you need that too. The `nrow`, `ncol`, `names` and `rownames` functions each return a vector, so we can assign the result if we need to use it later. For example, if we want to extract and store the column names for any reason we could use `varnames <- names(experim.data)`. 

## Extracting data from data frames {#extract-data}

Data frames would not be much use if we could not extract and modify the data in them. In this section we will briefly review how to carry out these kinds of operations using basic R functions.

### Extracting and adding a single variable

A data frame is just a collection of variables stored in columns, where each column is a vector of some kind. There are several ways to extract these variables from a data frame. If we just want to extract a single variable we have two options.

The first way of extracting a variable from a data frame uses a double square brackets construct, `[[`. For example, we extract the `Biomass` variable from our example data frame with the double square brackets like this:
```{r}
experim.data[["Biomass"]]
``` 
This prints whatever is in the `Biomass` column to the Console. What kind of object is this? It's a numeric vector:
```{r}
is.numeric(experim.data[["Biomass"]])
```
A data frame really is nothing more than a collection of vectors. Notice that all we did was print the resulting vector to the Console. If we want to actually do something with this numeric vector we need to assign the result:
```{r}
bmass <- experim.data$Biomass
bmass^2
```
Here, we extracted the `Biomass` variable, assigned it to `bmass`, and then squared this. The value of `Biomass` variable inside the `experim.data` data frame is unchanged.

Notice that we used `"Biomass"` instead of `Biomass` inside the double square brackets, i.e.  we quoted the name of the variable. This is because we want R to treat the word "Biomass" as a literal value. This little detail is important! If we don't quote the name then R will assume that `Biomass` is the name of an object and go in search of it in the global environment. Since we haven't created something called `Biomass`, leaving out the quotes generates an error:
```{r, error=TRUE}
experim.data[[Biomass]]
``` 
The error message is telling us that R can't find a variable called `Biomass` in the global environment. On the other hand, this example does work:
```{r, eval=TRUE}
vname <- "Biomass"
experim.data[[vname]]
``` 
This works because we first defined `vname` to be a character vector of length one, whose value is the name of a variable in `experim.data`. When R encounters `vname` inside the `[[` construct it goes and finds the value associated with it and uses this value to determine the variable to extract.

The second method for extracting a variable from a data frame uses the `$` operator. For example, to extract the `Biomass` column from the `experim.data` data frame, we use:
```{r}
experim.data$Biomass
```
We use the `$` operator by placing the name of the data frame we want to work with on the left hand side and and the name of the column (i.e. the variable) we want to extract on the right hand side. Notice that this time we didn't have to put quotes around the variable name when using the `$` operator. We can do this if we want to---i.e. `experim.data$"Biomass"` also works---but `$` doesn't require it.

Why is there more than one way to extract variables from a data frame? There's no simple way to answer this question without getting into the details of how R represents data frames. The simple answer is that `$` and `[[` are not actually equivalent, even though they appear to do much the same thing. We've looked at the two extraction methods because they are both widely used. However, the `$` method is a bit easier to read and people tend to prefer it for interactive data analysis tasks (the `[[` construct tends to be used when we need a bit more flexibility).

### Adding a variable to a data frame

How do we add a new variable to an existing data frame? It turns out that the `$` operator is also be used for this job by combining it with the assignment operator. Using it this way is fairly intuitive. For example, if we want to add a new (made up) variable called `Elevation` to `experim.data`, we do it like this:
```{r}
experim.data$Elevation <- c(364, 294, 321, 358, 298, 312)
```
This assigns some fake elevation data to a new variable in `experim.data` using the `$` operator. The new variable is called `Elevation` because that was the name we used on the right hand side of `$`. This changes `experim.data`, such that it now contains four columns (variables):
```{r}
head(experim.data, n = 3)
```

The `[[` operator can also be used with ` <- ` to add variables to a data frame. We won't bother to show an example, as it works in exactly the same way as `$` and we won't be using the `[[` method in this book.

### Subsetting data frames

What do we do if, instead of just extracting a single variable from a data frame, we need to select a subset of rows and/or columns? We use the single square brackets construct, `[`, to do this. There are two different ways we can use single square brackets, both of which involve the use of indexing vector(s) inside the `[` construct.

The first use of `[` allows us to subset one or more columns while keeping all the rows. This works exactly as the `[` does for vectors. Just think of columns as the elements of the data frame. For example, if we want to subset `experim.data` such that we are only left with the first and second columns (`Treatment` and `Biomass`), we can use a numeric indexing vector:
```{r}
experim.data[c(1:2)]
```
However, this is not a very good way to subset columns because we have to know the position of each variable. If for some reason we change the order of the columns, we have to update our R code accordingly. A better approach uses a character vector of column names inside the `[`:
```{r}
experim.data[c("Treatment", "Biomass")]
```

The second use of `[ ]` is designed to allow us to subset rows and columns at the same time. We have to specify both the rows and the columns we require, using a comma ("`,`") to separate a row and column index vector. This is easiest to understand with an example:
```{r}
# row index
rindex <- 1:3
# column index 
cindex <- c("Treatment", "Biomass")
# subset the data farme
experim.data[rindex, cindex]
```
This example extracts a subset of `experim.data` corresponding to rows 1 through 3, and columns "Treatment" and "Biomass". The `rindex` is a numeric vector of row positions, and `cindex` is a character vector of column names. This shows that rows and columns can be selected by referencing their position or their names. The rows are not named in `experim.data`, so we specified the positions.

Storing the index vectors first is quite a long-winded way of subsetting a data frame. However, there is nothing to stop us doing everything in one step:
```{r}
experim.data[1:3, c("Treatment", "Biomass")]
```
If we need to subset just rows or columns we just leave out the appropriate index vector:
```{r}
experim.data[1:3, ]
```
The absence of an index vector before/after the comma indicates that we want to keep every row/column. Here we kept all the columns but only the first three rows.

```{block, type="warning"}
#### Be careful with `[`

Subsetting with the `[rindex, cindex]` construct produces another data frame. This should be apparent from the way the last example was printed. This is __usually__ how this construct works. We say usually, because subsetting just one column produces a vector. This is very unfortunate, as it produces unpredictable behaviour if we're not paying attention.
```

The `[` construct works with three types of index vectors. We've just seen that the index vector can be a numeric or character type. The third approach uses a logical index vector. For example, we can subset the `experim.data` data frame, keeping just the rows where the `Treatment` variable is equal to "Control", using:
```{r}
# make a logical index vector
rindex <- experim.data $ Treatment == "Control"
rindex
# 
experim.data[rindex, ]
```
Notice that we construct the logical `rindex` vector by extracting the `Treatment` variable with the `$` operator and using the `==` operator to test for equality with "Control". Don't worry too much if that seems confusing. We combined many different ideas in that example. We're going to learn a much more transparent way to achieve the same result in later chapters.

## Final words

We've seen how to extract/add variables and subset data frames using the `$`, `[[` and `[` constructs. The last example also showed that we can use a combination of relational operators (e.g. `==`, `!=` or `>=`) and the square brackets construct to subset a data frame according to one or more criteria.  There are also a number of base R functions that allow us to manipulate data frames in a slightly more intuitive way. For example, there is a function called `transform` that adds new variables and changes existing ones, and a function called `subset` to select variables and subset rows in a data frame according to the values of its variables. 

We've shown you these approaches because they are still used by many people. However, we will rely on the **dplyr** package to handle operations like subsetting and transforming data frame variables in this book. The **dplyr** package provides a much cleaner, less error prone framework for manipulating data frames, and can be used to work with similar kinds of objects that store data in consistent way. Before we can do that though, we need to learn a little bit about how to organise and import data into R.

<!--chapter:end:2_01_data_frames.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Working directories and data files

## Introduction 

R is able to access data from a huge range of different data storage formats and repositories. With the right tools, we can use R to pull in data from various data bases, proprietary storage formats (e.g. Excel), online web sites, or plain old text files. We aren't going to evaluate the many packages and functions used to pull data into R---a whole book could be written about this topic alone. Instead, we're going to examine the simplest method for data import: reading in data from a text file. We'll also briefly look at how to access data stored in packages. 

## Data files: the CSV format

Just about every piece of software that stores data in some kind of table-like structure can export those data to a CSV file. The CSV acronym stands for "Comma Separated Values". CSV files are just ordinary text files. The only thing that makes them a CSV file is the fact that they store data in a particular format. This format is very simple: each row of a CSV file corresponds to a row in the data, and each value in a row (corresponding to a different column) is separated by a comma. Here is what the artificial data from the last chapter looks like in CSV format:

```{r, echo=FALSE}
trt <- rep(c("Control","Fertilser"), each = 3) 
bms <- c(284, 328, 291, 956, 954, 685)
div <- c(8, 12, 11, 8, 4, 5)
experim.data <- data.frame(trt, bms, div)
write.csv(experim.data, row.names = FALSE)
```

The first line contains the variable names, with each name separated by a comma. It's usually a good idea to include the variable names in a CSV file, though this is optional. After the variable names, each new line is a row of data. Values which are not numbers have double quotation marks around them; numeric values lack these quotes. Notice that this is the same convention that applies to the elements of atomic vectors. Quoting non-numeric values is actually optional, but reading CSV files into R works best when non-numeric values are in quotes because this reduces ambiguity. 

### Exporting CSV files from Excel

Those who work with small or moderate data sets (i.e. 100s-1000s of lines) often use Excel to manage and store their data. There are good reasons for why this isn't necessarily a sensible thing to do---for example, Excel has a nasty habit of "helpfully" formatting data values. Nonetheless, Excel is a ubiquitous and convenient tool for data management, so it's important to know how to pull data into R from Excel. It is possible to read data directly from Excel into R, but this way of doing things can be error prone for an inexperienced user and requires us to use an external package (the **readxl** package is currently the best option). Instead, the simplest way to transfer data from Excel to R is to first export the relevant worksheet to a CSV file, and then import this new file using R's standard file import tools. 

We'll discuss the import tools in a moment. The initial export step is just a matter of selecting the Excel worksheet that contains the relevant data, navigating to `Save As...`, choosing the `Comma Separated Values (.csv)`, and following the familiar file save routine. That's it. After following this step our data are free of Excel and ready to be read into R.

```{block, type="warning"}
#### Always check your Excel worksheet

Importing data from Excel can turn into a frustrating process if we're not careful. Most problems have their origin in the Excel worksheet used to store the data, rather than R. Problems usually arise because we haven't been paying close attention to a worksheet. For example, imagine we're working with a very simple data set, which contains three columns of data and a few hundred rows. If at some point we accidentally (or even intentionally) add a value to a cell in the forth column, Excel will assume the fourth column is "real" data. When we then export the worksheet to CSV, instead of the expected three columns of data, we end up with four columns, where most of the fourth column is just missing information. This kind of mistake is surprisingly common and is a frequent source of confusion. The take-home message is that when Excel is used to hold raw data should be used to do just that---the worksheet containing our raw data should hold only that, and nothing else.
```

## The working directory

Before we start worrying about data import, we first need to learn a bit about how R searches for the files that reside on our computer's hard drive. The key concept is that of the "working directory". A "directory" is just another word for "folder". The working directory is simply a default location (i.e. a folder) R uses when searching for files. The working directory must always be set, and there are standard rules that govern how this is chosen when a new R session starts. For example, if we start R by double clicking on an script file (i.e. a file with a ".R" extension), R will typically set the working directory to be the location of the R script. We say typically, because this behaviour can be overridden. 

There's no need to learn the rules for how the default working directory is chosen, because we can always use R/RStudio to find out which folder is currently set as the working directory. Here are a couple of options:

1. When RStudio first starts up, the __Files__ tab in the bottom right window shows us the contents (i.e. the files and folders) of the working directory. Be careful though, if we use the file viewer to navigate to a new location this does not change the working directory.

2. The `getwd` function will print the location to the working directory to the Console. It does this by displaying a __file path__. If you're comfortable with file paths then the output of `getwd` will make perfect sense. If not, it doesn't matter too much. Use the RStudio __Files__ tab instead.

Why does any of this matter? We need to know where R will look for files if we plan to read in data. Fortunately, it's easy to change the working directory to a new location if we need to do this: 

1. Using RStudio, we can set the working directory via the `Session > Set Working Directory... > Choose Directory...` menu. Once this menu item is selected we're presented with the standard file/folder dialogue box to choose the working directory.

2. Alternatively, we can use a function called `setwd` at the Console, though once again, we have to be comfortable with file paths to use this. Using RStudio is easier, so we won't demonstrate how to use `setwd`.

## Importing data with `read.csv`

Now that we know roughly how a CSV file is formatted, and where R will look for such files, we need to understand how to read them into R. The standard R function for reading in a CSV file is called `read.csv`. There are a few other options (e.g. `read_csv` from the **readr** package), but we'll use `read.csv` because it's part of the base R distribution, which means we can use it without relying on an external package. 

The `read.csv` function does one thing: given the location of a CSV file, it will read the data into R and return it to us as a data frame. There are a couple of different strategies for using `read.csv`. One is considered good practice and is fairly robust. The second is widely used, but creates more problems than it solves. We'll discuss both, and then explain why the first strategy is generally better than the second.
  
#### Strategy 1---set the working directory first

Remember, the working directory is the default location used by R to search for files. This means that if we set the working directory to be wherever our data file lives, we can use the `read.csv` function without having to tell R where to look for it. Let's assume our data is in a CSV file called "my-great-data.csv". We should be able to see "my-great-data.csv" in the __Files__ tab in RStudio if the working directory is set to its location. If we can't see it there, the working directory still needs to be set (e.g. via `Session > Set Working Directory... > Choose Directory...`). 

Once we've set the working directory to this location, reading the "my-great-data.csv" file into R is simple:
```{r, eval=FALSE}
my_data <- read.csv(file = "my-great-data.csv", stringsAsFactors = FALSE)
```
R knows where to find the file because we first set the working directory to be the location of the file. If we forget to do this R will complain and throw an error. We have to assign the output a name so that we can actually use the new data frame (`my_data` in this example), otherwise all that will happen is the resulting data frame is read in and printed to the Console.

#### Strategy 2---use the full path to the CSV file

If we are comfortable with "file paths" then `read.csv` can be used without bothering to set the working directory. For example, if we have the CSV file called "my-great-data.csv" on the in a folder called "r_data", then on a Unix machine we might read it into a data frame using something like:
```{r, eval=FALSE}
my_data <- read.csv(file = "~/r_data/my-great-data.csv", stringsAsFactors = FALSE)
```
When used like this, we have to give `read.csv` the full path to the file. This assumes of course that we understand how to construct a file path---the details vary depending on the operating system.

#### Why use the first strategy?

Both methods get to the same end point: after running the code at the Console we should end up with an object called `my_data` in the global environment, which is a data frame containing the data in the "my-great-data.csv" file. So why should we prefer 

1. Many novice R users with no experience of programming struggle with file paths, leading to a lot of frustration and wasted time trying to specify them. The first method only requires us to set the working directory with RStudio and know the name of the file we want to read in. There's no need to deal with file paths.

2. The second strategy creates problems when we move your data around or work on different machines, as the file paths will need to be changed in each new situation. The first strategy is robust to such changes. For example, if we move all our data to a new location, we just have to set the working directory to the new location and our R code will still work. 

## Importing data with RStudio (Avoid this!)

It is also possible to import data from a CSV file into R using RStudio. The steps are as follows:

1. Click on the __Environment__ tab in the top right pane of RStudio

2. Select `Import Dataset > From Text File...`

3. Select the CSV file you want to read in to R and click Open

4. Enter a name (no spaces allowed) or stick with the default and click Import

We're only pointing out this method because new users are often tempted to use it---we **do not** recommend it. Why? It creates the same kinds of problems as the second strategy discussed above. All RStudio does generate the correct usage of a function called `read_csv` (from the **readr** package) and evaluate this at the Console. The code isn't part of a script so we have to do this every time we want to work with the data file. It's easy to make a mistake using this approach, e.g. by accidentally misnaming the data frame or reading in the wrong data. It may be tempting to copy the generated R code into a script. However, we still have the portability problem outlined above to deal with. Take our word for it. The RStudio-focussed way of reading data into R just creates more problems than it solves. Don't use it.

## Package data

Remember what Hadley Wickam said about packages? "... <Packages> include reusable R functions, the documentation that describes how to use them, __and sample data__." Many packages come with one or more sample data sets. These are very handy, as they're used in examples and package vignettes. We can use the `data` function to get R to list the data sets hiding away in packages:
```{r, eval=FALSE}
data(package = .packages(all.available = TRUE))
```
The mysterious `.packages(all.available = TRUE)` part of this generates a character vector with the names of all the installed packages in it. If we only use `data()` then R only lists the data sets found in a package called `datasets`, and in packages we have loaded and attached in the current R session using the `library` function.

The `datasets` package is part of the base R distribution. It exists only to store example data sets. The package is automatically loaded when we start R, i.e. there's no need to use `library` to access it, meaning any data stored in this package can be accessed every time we start R. We'll use a couple of data sets in the `datasets` package later to demonstrate how to work with the **dplyr** and **ggplot2** packages.



<!--chapter:end:2_02_getting_data.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Working directories and data files

## Introduction 

---
layout: default
title: Manipulating variables with __dplyr__
---

```{r, include=FALSE}
library("dplyr")
library("nasaweather")
```

This chapter will explore the the **dplyr** `select` and `mutate` verbs, as well as the related `rename` and `transmutate` These are discussed together because both are used to manipulate variables in objects like data frames and tables. The `select` function subsets and renames variables. The `mutate` function creates new ones.

If you have not already done so, now is the time to install `dplyr` and the `nasaweather` packages using `install.packages`. You will want to start a new script to explore the examples in this topic as you work through them. The first couple of lines should load these two packages:
```{r, eval=FALSE}
library("dplyr")
library("nasaweather")
```

We will use the `iris` dataset in the `datasets` package and `storms` dataset in the `nasaweather` package to learn about `select` and `mutate`. The copy of `iris` dataset is an ordinary data frame. Before we start, we need to convert this to table so that it prints to the Console in a more compact way:
```{r}
iris <- tbl_df(iris)
```
This is another line you will want to add to your `dplyr` examples script.

## Subset variables with `select`

We use `select` to __subset variables__ in an object containing our data. This is useful if we only need to work with a few variables in a large dataset. Basic usage of `select` looks something like this:
```{r, eval=FALSE}
select(dobj, vname1, vname2, ...)
```
This is not an example you can run. It is just designed to highlight in general terms how we use `select`. The first argument, `dobj` ("data object"), must be the name of the object containing our data. We then include a series of one or more additional arguments, where each of these should be the name of a variable in `dobj`. I have expressed this as `vname1, vname2, ...`, where `vname1` and `vname2` are names of the first two variables, and the `...` is acting as placeholder for the remaining variables (there could be any number of these).

It is easiest to understand how a function like `select` works by just using it. We use it to select the `Species`, `Petal.Length` and `Petal.Width` variables from `iris` like this:
```{r}
select(iris, Species, Petal.Length, Petal.Width)
```
Hopefully nothing about this example is surprising or confusing. There are a few things to notice about how `select` works though:

* The variable names are not surrounded by quotes. The `select` function is one of those non-standard functions we briefly mentioned in the [Functions]({{ site.baseurl }}/functions.html)) topic. It looks inside our data object for variables, rather than searching elsewhere.

* We just printed the result produced by `select` to the Console in this example. Since we did not assign the result a name using ` <- `, we cannot access it in future. Remember, `select` is just like other R functions. It does not have side effects, meaning it does not change the original `iris` in any way. 

* The order of variables (i.e. the column order) in the resulting table is the same as the order in which they were used as arguments. This means we can reorder variables at the same time as selecting them if we need to.

* The `select` function will return the same kind of data object it is working on. It returns a data frame if our data was originally in a data frame and a table if it was a table. In this example, R prints a table because we had converted `iris` from a data frame to a table.

Sometimes it is more convenient to subset variables specifying those we do __not__ need, rather than in terms of the ones we would like to keep. We use the `-` operator indicate that variables should be dropped. For example, to drop the `Petal.Width` and `Petal.Length` columns, we use:
```{r}
select(iris, -Petal.Width, -Petal.Length)
```
This returns a table with just the remaining variables:`Sepal.Length`, `Sepal.Width` and `Species`.

It can sometimes be quicker to select (or drop) a set of variables positioned in a next to one another. We work with a series of adjacent variables using the `:` operator. This is used with two variable names, one on the left hand side and one on the right. When we use `:` like this `select` will subset both those variables along with any others that fall in between them. For example, if we need the two `Petal` variables and `Species`, we use:
```{r}
select(iris, Petal.Length:Species)
```
The `:` operator can be combined with `-` if we need to drop a series of variables according to their position in a data frame or table.

### Helper functions

There are a number of __helper functions__ which can be used with `select` to select according to various criteria. We will just look at the three simplest of these. You should look at the examples in the help file for `select` and that [handy cheat sheat](http://www.rstudio.com/resources/cheatsheets/) to see what else is available.

We can select variables according to the sequence of characters used at the start of their name with the `starts_with` function. For example, to select all the variables in `iris` that begin with the word "Petal", we use:
```{r}
select(iris, starts_with("petal"))
```
This returns a table containing just `Petal.Length` and `Petal.Width`. As you might expect, there is also a helper function to select variables according to characters used at the end of their name. This is the `ends_with` function (no surprises here). To select all the variables in `iris` that end with the word "Length", we use:
```{r}
select(iris, ends_with("length"))
```

Notice that we have to quote the character string that we want to match against. This is not optional. However, the `starts_with` and `ends_with` functions are not case sensitive by default. For example, I passed `starts_with` the argument `"petal"` instead of `"Petal"`, yet it still selected variables beginning with the character string `"Petal"`. If you want to select variables on a case-sensitive basis, you need to set an argument `ignore.case` to `FALSE` in `starts_with` and `ends_with`.

The last `select` helper function we will look at is called `contains`. You can guess what this does. It allows us to select variables based on a partial match anywhere in their name. Look at what happens if we pass `contains` the argument `"."`:
```{r}
select(iris, contains("."))
```
This selects all the variables with a dot in their name. 

There is nothing to stop us combining the different variable selection methods. For example, we can use this approach to select all the variables whose names start with the word "Petal" or end with the word "Length":
```{r}
select(iris, ends_with("length"), starts_with("petal"))
```
When we apply more than one selection criteria like this the `select` function returns all the variables that match one or more criteria, rather than just the set that meets all the criteria.

### Renaming variables with `select` and `rename`

In addition to selecting a subset of variables, the `select` function can also rename variables at the same time. We have to name the arguments with `=`, placing the new name on the left hand side, to do this. For example, to select the`Species`, `Petal.Length` and `Petal.Width` variables from `iris`, but also rename `Petal.Length` and `Petal.Width` to `PetalLength` and `PetalWidth`, we use:
```{r}
select(iris, Species, PetalLength = Petal.Length, PetalWidth = Petal.Width)
```

Renaming variables is common task when working with data frames and tables. In many cases the _only_ thing we would like to do is rename a variable or two. That is, we would like to certain rename variables without selecting a subset. The `select` function is not very good at this because you have to supply every variable in the focal data object as an argument to avoid dropping it. The `dplyr` provides an additional function called `rename` for this reason. The sole purpose of the `rename` function is to rename certain variables while retaining any others. It works exactly as you would expect it to. For example, in order to rename `Petal.Length` and `Petal.Width` to `PetalLength` and `PetalWidth`, we use:
```{r}
rename(iris, PetalLength = Petal.Length, PetalWidth = Petal.Width)
```
Notice that the rename function also preserves the order of the variables as found in the original data.

<div class="exercise-box">
#### Using `select` to subset variables
<div class="box-text">
This exercise should be easy. Using the `storms` dataset, see if you can make the following table:
```{r, echo=FALSE}
select(storms, -(year:wind), -seasday)
```
Do this in two ways. First make this table by specifying the names of variables to retain, then repeat the exercise by only specifying the names of variables to drop. In each case, you are only allowed to pass three arguments to `select`.
</div>
</div>

## Creating variables with `mutate`

We use `mutate` to __add new variables__ to an object containing our data. This is useful if we need to construct one or more derived variables to support an analysis. Basic usage of `mutate` looks something like this:
```{r, eval=FALSE}
mutate(dobj, <expression1>, <expression2>, ...)
```
This is not an example you can run. It is intended to highlight in general terms how we use `mutate`. As is always the case with `dplyr` functions, the first argument, `dobj` ("data object"), should be the name of the object containing our data. We then include a series of one or more additional arguments, where each of these is a valid R expression involving one or more variables in `dobj`. I have expressed these as `<expression1>, <expression2>`, where `<expression1>` and `<expression2>` represent the first two expressions, and the `...` is acting as placeholder for the remaining expressions. This is not valid R code -- remember, it is just intended to show you the general form of `mutate`.

To see `mutate` in action, let's construct a new version of `iris` that contains a variable summarising the approximate area of sepals:
```{r}
mutate(iris, Sepal.Width * Sepal.Length)
```
This created a copy of `iris` with a new column called `Sepal.Width * Sepal.Length` (it is mentioned at the bottom of the printed output). Most of the rules that apply to `select` also apply to `mutate`:

* The expression that performs the required calculation is not surrounded by quotes. This makes sense, because an expression is meant to be evaluated so that it "does something". It is not a value. 

* Once again, we just printed the result produced by `mutate` to the Console, rather than assigning the result a name using ` <- `. The `mutate` function does not have side effects, meaning it does not change the original `iris` in any way. 

* The `select` function returns the same kind of data object as the one it is working on: a data frame if our data was originally in a data frame, a table if it was a table.

Creating a variable called something like `Sepal.Width * Sepal.Length` is not exactly ideal. Happily, the `mutate` function can name variables at the same time as they are created. We have to name the arguments using `=`, placing the name on the left hand side, to do this. We can use this construct to name the area variable `Sepal.Area`:
```{r}
mutate(iris, Sepal.Area = Sepal.Width * Sepal.Length)
```

We can create more than one variable by supplying `mutate` multiple (named) arguments:
```{r}
mutate(iris, 
       Sepal.Area = Sepal.Width * Sepal.Length,
       Petal.Area = Petal.Width * Petal.Length,
       Area.Ratio = Petal.Area / Petal.Area)
```
Notice that I placed each argument on a new line (remembering the comma to separate arguments). There is nothing to stop us doing this -- R does not care about white space. This is useful because it makes long function calls easier to read.

This last example reveals a nice feature of `mutate`: we can use newly created variables in further calculations. Here we constructed approximate sepal and petal area variables, and then used these to construct a third variable containing the ratio of these two quantities, `Area.Ratio`.

### Helper functions

There are quite a few __helper functions__ that can be used with `mutate`. These make it easier to add new variables according to the values of other variables. We won't explore these here as they tend to be needed only in quite specific circumstances. However, if you run into a situation where you need to construct an unusual variable -- for example, one that ranks the values in another variable -- you may want to try looking at the examples in the `mutate` help file or that [handy cheat sheat](http://www.rstudio.com/resources/cheatsheets/) to see what options are available to you.

### Transforming and dropping variables

Occasionally we may want to construct one or more new variables, and then drop all other variables in the original dataset. The `transmute` function is designed to do this:
```{r}
transmute(iris,
          Sepal.Area = Sepal.Width * Sepal.Length,
          Petal.Area = Petal.Width * Petal.Length,
          Area.Ratio = Petal.Area / Petal.Area)
```
Here we repeated the previous example, but now only the new variables were retained in the resulting table. If we also want to retain one or more variables without altering them we just have to pass them as unnamed arguments. For example, if we need to retain species identity in the output, we use: 
```{r}
transmute(iris,
          Species,
          Sepal.Area = Sepal.Width * Sepal.Length,
          Petal.Area = Petal.Width * Petal.Length,
          Area.Ratio = Petal.Area / Petal.Area)
```

<div class="exercise-box">
#### Using `mutate` to add a date variable
<div class="box-text">
There are several ways to work with date and time information in R. We do not have the time in this course to really examine these. However, to get a brief taste of how dates can be managed we will take a quick look at how to construct something called a `Date` vector.

The `storms` dataset contains three variables that describe the date each observation was taken: `year`, `month` and `day`. Each of these is numeric. The `paste` function can be used to paste together the values of numeric and/or character vector on an element-by-element basis. The output of `paste` is always a character vector. See if you can use the `transmute` function to construct the following table:
```{r, echo=FALSE}
transmute(storms, name, chardate = paste(year, month, day, sep="-"))
```
Hint: the `paste` function has an argument called `sep`. This is used to specify the character(s) used to separate the elements being pasted together. 

If you managed to do the first step using `paste` the next step is easy. Use the `as.Date` function of the year-month-day character vector to construct a new `Date` variable called "`obsdate`". You should end up with something like this:
```{r, echo=FALSE}
transmute(storms, name, 
          chardate = paste(year, month, day, sep="-"), 
          obsdate = as.Date(chardate))
```
</div>
</div>







<!--chapter:end:2_03_dplyr_variables.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# (PART) Exporing Data {-}


<!--chapter:end:3_00.Rmd-->

