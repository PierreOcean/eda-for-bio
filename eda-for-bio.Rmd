--- 
title: "APS 135: Introduction to Exploratory Data Analysis with R"
author: "Dylan Z. Childs"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output:
  bookdown::gitbook:
    includes:
      in_header: extras.css
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
github-repo: dzchilds/eda-for-bio
description: "Course book for Introduction to Exploratory Data Analysis with R (APS 135) in the Department of Animal and Plant Sciences, University of Sheffield."
---
```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```

# Course information and overview

This is the online course book for the __Introduction to Exploratory Data Analysis with R__ component of ([APS 135](https://www.shef.ac.uk/aps/currentug/level2/aps135)) module. You can view this book in any modern desktop browser, as well as on your phone or tablet device. The site is self-contained---it contains all the material you are expected to learn this year.

[Dylan Childs](https://www.shef.ac.uk/aps/staff-and-students/acadstaff/childs) is the course co-coordinator. Please [email him](mailto:d.childs@sheffield.ac.uk?Subject=APS%20133%20general%20query) if you have have any general queries about the course. The Teaching Assistants ('TAs') this year are Ross Booton, Matthew Hethcoat, Bethan Hindle, Tamora James, Felix Lim, and Simon Mills.

## Organisation

```{block, type="action"}
This is an **action** box.
```

```{block, type="warning"}
This is a **warning** box.
```

```{block, type="info"}
This is an **information** box.
```



Some text...


<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Expected learning outcomes

## Introduction to R

## Data Wrangling

## Exporing Data

<!--chapter:end:0_01_learning_outcomes.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# (PART) Introduction to R {-}


<!--chapter:end:1_00.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Get up and running with R and RStudio

## What is R? {#what-is-r}

The answer to this question very much depends on who we ask. The geeky answer is something like this... 

R is a dialect of the S language, which was developed by John Chambers and colleagues at Bell Laboratories in the mid 1970s. It was designed to offer an interactive  computing environment for statisticians and scientists to carry out data analysis. There are essentially two widely used versions of S (though others have started to appear), a commercial one called S-Plus, and the open source implementation known as R. S-Plus came first, and although it is still around, it is used less each year. Development of R was begun in the late 1990s by two academics, Ross Ihaka and Robert Gentleman, at the University of Auckland. Their motivation was to create an open source language to enable researchers in computational statistics to explore new ideas. That language quickly evolved into something that looked more and more S-like, which we now know as R (GNU R, to be overly precise).

We could go on and on about the various features that R possesses. R is a functional programming language, it supports object orientation, etc etc... but these kinds of explanations are only helpful to someone who already knows about computer languages. It is useful to understand why so many people have turned to R to meet their data analysis needs. When a typical R user talks about "R" they are often referring to two things at once, the GNU R language and the ecosystem that exists around the language:

* R is all about data analysis. We can carry out any standard statistical analysis in R, as well as access a huge array of more sophisticated tools with impressive names like "structural equation model", "random forests" and "penalized regression". These days, when statisticians and computer scientists develop a new analysis tool, they often implement it in R first. This means a competent R user can always access the latest, cutting edge analysis tools. R also has the best graphics and plotting facilities of any platform. With sufficient expertise, we can make pretty much any type of figure we need (e.g. scatter plots, phylogenetic trees, spatial maps, or even [volcanoes](http://www.r-project.org/screenshots/volcano-image.jpg)). In short, R is a very productive environment for doing data analysis.

* Because R is such a good environment for data analysis, a very large community of users has grown up around it. The size of this community has increased steadily since R was created, but this growth has really increased up in the last 5-10 years or so. In the early 2000s there were very few books about R and the main way to access help online was through the widely-feared R mailing lists. Now, there are probably hundreds of books about different aspects of R, online tutorials written by enthusiasts, and many websites that exist solely to help people learn R. The resulting ecosystem is vast, and though it can be difficult to navigate at times, when we run into an R-related problem the chances are that the answer is already written down somewhere^[The other big change is that R is finally starting to become part of the commercial landscape---learning how to use it can only improve your job prospects.].

R is not just about data analysis---though we will mostly use it this way. It is a fully-fledged programming language, meaning that once you become moderately proficient with it you can do things such as construct numerical simulation models, solve equations, query websites, send emails, [access the foaas web service](http://cran.r-project.org/web/packages/rfoaas/), and carry out many other tasks we don't have time to write down. We won't do any of this year or next but it is worth noting that R can do much more than just analyse data if we need it to.

### Getting and installing R

R is open source, meaning anyone can download the source code -- the collection of computer instructions that define R -- and assuming they have enough time, energy and expertise, they are free to alter it as they please. Open source does not _necessarily_ mean free, as in it costs £0 to download and use, but luckily R _is_ free in this sense. If you are working on the University managed desktops it should already have been installed and is ready for you to use. We encourage you to install a copy on your own laptop so that you can work at home, in the library, at a café, or wherever else you find you are productive. Do not use R on its own though. Use it in combination with the RStudio IDE discussed in the next section. 

In order to install R you need to download the appropriate installer from the Comprehensive R Archive Network ([CRAN](http://cran.r-project.org)). We are going to use the "base distribution" as this contains everything you need to use R under normal circumstances. There is a single [installer](http://cran.r-project.org/bin/windows/base/) for Windows. On a Mac, it's important to match the [installer](http://cran.r-project.org/bin/macosx/) to the version of OS X. In either case, R uses a the standard install mechanism that should be familiar to anyone who has installed an application on their machine. There is no need to change the default settings---doing so will probably lead to problems later on.

```{block, type="action"}
Go ahead and install R on your own computer. You won't be able to make much use of this book without it!
```

After installing R it should be visible in the Programs menu on a Windows computer or in the Applications folder on a Mac. However, it would be a good idea to read the next section before launching R...

## What is RStudio (and why use it)? {#what-is-rstudio}

R and RStudio are not the same thing. We can run R without RStudio if we need to, but we cannot run RStudio without R. Remember that! R is essentially just a computer program that sits there and waits for instructions in the form of text. Those instructions can be typed in by a user like you or me, or they can be sent to it from another program. This means you can run R in a variety of different environments. The job of RStudio is to provide an environment that makes R a more pleasant and productive tool. One way to get a sense of why RStudio is a Very Good Thing is to look at what running R without it is like. The simplest way to run it on a Linux or Unix-based machine (like a Mac) is to use something called the Terminal. It's well beyond the scope of this book to get into what this is, but in a nutshell, the Terminal provides a low-level, text-based way to interact with a computer. Here is what R looks like running inside a Terminal on a Mac:

```{r, echo=FALSE}
knitr::include_graphics("images/R-terminal.png")
```

We can run R in much the same way on Windows using the "Command Prompt" if we need to. The key thing you need to take away from that screenshot is that running R like this is very "bare bones". We typed the letter "R" in the Terminal and hit Enter to start R. It printed a little information as it started up and then presented us with "the prompt" (`> `), waiting for input. This is where we type or paste in instructions telling R what to do. There is no other way to interact with it when we run R like this -- no menus or buttons, just a lonely prompt.

```{block, type="warning"}
The developers of R on Windows PCs and Macs provide a slightly nicer way to work with R. When we download and install R for either of these two operating systems, in addition to the basic R program that we just saw running in a Terminal, we also get another program that acts as a [Graphical User Interface](http://en.wikipedia.org/wiki/Graphical_user_interface) (GUI) for R. This is the thing labelled "R" in the Programs menu on a Windows computer or the Applications folder on a Mac. If you launch the R GUI on your computer you will be presented with roughly the same thing on either a Windows PC or a Mac. There will be something called the Console, which is where you interact directly with R by typing things at the prompt (which looks like this: `> `), and a few buttons and menus for managing common tasks. We will not go through these two GUIs in any more detail because we are not going to use them. We just need to know they exist so we don't confuse them with RStudio.
```

So what is RStudio? The first thing to note is that it is a different program from R. Remember that! RStudio is installed installed separately from R and occupies its own place in the Programs menu (Windows PC) or Applications folder (Mac). In one sense RStudio is just another Graphical User Interface for R which improves on the "bare bones" experience. However, it is a GUI on steroids. It is more accurate to describe it as an [Integrated Development Environment](http://en.wikipedia.org/wiki/Integrated_development_environment) (IDE). There is no all-encompassing definition of an IDE, but they all exist to make programmer's lives easier by integrating various useful tools into a single piece of software. From the perspective of this book, there are four key features that we care about:

* The R interpreter---the thing that was running in the Terminal above---runs inside RStudio. It's accessed via a window labelled Console. This is where we type in instructions we want to execute when we are working directly with R. The Console also shows us any output that R prints in response to these instructions. So if we just want the "bare bones" experience, we can still have it.  

* RStudio provides facilities for working with R programs using something called a Source Code Editor. An R program ( also called a "script")" is just is a collection of instructions in the R language that have been saved to a text file. Nothing more! However, it is much easier to work with a script using a proper Source Code Editor than an ordinary text editor like Notepad.

* An good IDE like RStudio also gives you a visual, point-and-click means of accessing various language-specific features. This is a bit difficult to explain until we have have actually used some of these, but trust us, being able to do things like manage packages, set working directories, or inspect objects we've made simplifies day-to-day use of R. This especially true for new users.

* RStudio is cross-platform---it will run on a Windows PC, a Linux PC or a Mac. In terms of the appearance and the functionality it provides, RStudio is exactly the same on each of these platforms. If we learn to work with R via RStudio on a Windows PC, it's no problem migrating to a Mac or Linux PC later on if we need to. This is a big advantage for those of us who work on multiple platforms.

We're only going to scratch the surface of what RStudio can do and there are certainly alternative bits of software that could meet our immediate needs. The reason for introducing a powerful tool like RStudio is because one day you may need to access things like debugging facilities, package building tools, repository management. RStudio makes it easy to use these advanced tools.

### Getting and installing RStudio

RStudio is developed and maintained by a for-profit company called... RStudio. They make their money by selling software tools and services related to R and RStudio. The basic desktop version of RStudio is free to download and use though. It can be downloaded from the RStudio [download page](http://www.rstudio.com/products/RStudio/#Desk). The one to go for is the Open Source Edition of RStudio Desktop, __not__ the commercial version of RStudio Desktop. RStudio installs like any other piece of software, so there's nothing to configure after installation.

```{block, type="action"}
If you haven't already done it, go ahead and install RStudio Desktop on your own computer. You are going to need it.
```

### The anatomy of RStudio 

Once it's installed RStudio is run like any other stand-alone application, via the Programs menu or the Applications folder on a Windows PC or Mac, respectively^[If you use a computer running Linux we assume you know what you are doing when it comes to installing and running software.]. We'll say this one last time---RStudio only works if we've also installed R. Here is how RStudio appears the first time it runs:

```{r, echo=FALSE}
knitr::include_graphics("images/RStudio-3-pane.png")
```

There are three panes inside a single window, which we have labelled with red numbers. Each of these has a well-defined purpose. Let's take a quick look at these:

1. The large window on the left is the Console. We have already told you what this is for---the Console lets you know what R is doing and provides a mechanism to interact with R by typing instructions. All this happens at the prompt, `> `. We will be working in the Console in a moment so won't say any more about this here.

2. The window at the top right contains two tabs. The first of these, labelled __Environment__, allows us to see all the different R objects we can access. There are also some buttons that help us to get data into and out of R. The second, labelled __History__, allows us to see a list of instructions we've previously sent to R. The buttons in this tab allow us to reuse or save these instructions.

3. The window at the bottom right contains five tabs. The first, labelled __Files__, gives us a way to interact with the files and folders. The next tab, labelled __Plots__, is where any figures we produce are displayed. This tab also allows you to save your figures to file. The __Packages__ tab is where we view, install and update packages used to extend the functionality of R. The __Help__ tab is where you can access and display various different help pages. The __Viewer__ is essentially an embedded web browser for working with interactive output---we won't be using it in this course.

Don't be alarmed if RStudio looks different on your computer. There are a couple of reasons why this might be the case. First, the appearance of RStudio is highly customisable. Take a quick look at the `Tools > Global Options...` window to see what we mean. Second, there is a fourth window that is sometimes be visible when we work with RStudio---the source code Editor we mentioned above. RStudio saves its state between different sessions, so if we have already messed about with RStudio's appearance or left a script open last time we used it you will see these changes.

```{block, type="warning"}
Keep in mind that RStudio is very actively developed, which means features tend to appear or change over time. Consequently, if you update it regularly expect the odd thing to change here and there. This is generally a good thing---it usually means new features have been added---but it does require you to occasionally adjust to new additions.
```

## Working at the Console {#Console}

R was designed to be used interactively---it is what is known as an **interpreted language**, which we can interact with via something called a Command Line Interface (CLI). This is just a fancy way of saying that we can type an instructions to "do something" directly into the Console and those instructions will then be interpreted when we hit the Enter key. If our R expression does not contain any errors, R will then do something like read in some data, perform a calculation, make a figure, and so on. What actually happens obviously depends on what we ask it to do.

Let's briefly see what all this means by doing something very simple with R. Type `1 + 3` at the Console and hit the Enter key:
```{r}
1+3
```
The first line above just reminds us what we typed into the Console. The line after that beginning with `## ` shows us what R printed to the Console after reading and evaluating our instructions. 

What just happened? We can ignore the `[1]` bit for now (the meaning of this will become clear later in the course). What are we left with -- the number 2. The instruction we gave R was in effect "evaluate the expression `1 + 3`". R read this in, decided it was a valid R expression, evaluated the expression, and then printed the result to the Console for us. Unsurprisingly, the expression `1 + 3` is a request to add the numbers 1 and 3, and so R prints the number 4 to the Console.

OK, that was not very exciting. In the next chapter we will start learning to use R to carry out more useful calculations. The important take-away from this is that this sequence of events---reading instructions, evaluating those instructions and printing their output---happens every time we type or paste something into the Console and hit Enter. The printing bit is optional by the way. Whether or not it happens depends on whether you decide to capture the output or not. Just remember, if R does not print anything to the Console it does not necessarily mean nothing has happened.

```{block, type="info"}
Why do we keep using that word _expression_? It has a very specific meaning in computer science. The [Wikipedia page](http://en.wikipedia.org/wiki/Expression_(computer_science)) says:

> An expression in a programming language is a combination of explicit values, constants, variables, operators, and functions that are interpreted according to the particular rules of precedence and of association for a particular programming language, which computes and then produces another value.

That probably doesn't make much sense (which is why we don't let computer scientists teach biologists to program). Essentially, an R expression is a small set of instructions written in human readable(ish) text that tell R to do something. That’s it. We could write "instructions" instead of "expressions" throughout this book but we may as well use the correct word. Whatever we call them, our aim is to learn how to combine sequences of expressions to Get Things Done in R. That's what the rest of this book is about.
```










<!--chapter:end:1_01_R_and_RStudio.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# A quick introduction to R

## Using R as a big calculator {#r-calculator}

### Basic arithmetic

At the end of the last chapter we saw that R can apparently handle familiar arithmetic operations: addition, subtraction, multiplication, division. If we want to add or subtract a pair of numbers just place the `+` or `-` symbol in between two numbers, hit Enter, and R will read in your calculation, evaluate it, and print the result to the Console. This works exactly as we expect it to:
```{r}
3 + 2
5 - 1
```
Multiplication and division are no different, though we don't use `x` or `÷` for these operations. Instead, we use `*` and `/` to multiply and divide:
```{r}
7 * 2
3 / 2
```
We can also exponentiate a numbers: raise one number to the power of another. We use the `^` operator to do this:
```{r}
4^2
```
This raises 4 to the power of 2 (i.e. we squared it). In general, we can raise a number `x` to the power of `y` using `x^y`. Neither `x` or `y` need to be a whole numbers either.

Arithmetic operations can also be combined into one expression. Assume we want to subtract 6 from 2^3^. The expression to perform this calculation is:
```{r}
2^3 - 6
```
$2^3=8$ and $8-6=2$. Simple enough, but what if we had wanted to carry out a slightly longer calculation that required the last answer to then be divided by 2? This is the **wrong** the way to do it:
```{r}
2^3 - 6 / 2
```
The answer we were looking for is $1$. So what happened? R evaluated $6/2$ first and then subtracted this answer from $2^3$.

If that's obvious, great. If not, it's time to learn a bit about the __order of precendence__ used by R. R uses a standard set of rules to decide the order in which arithmetic calculations feed into one another so that it can unambiguously evaluate any expression. It uses the same order as every other computer language, which thankfully is the same one we all learned in mathematics class at school. The order of precendence used is:

1. exponents and roots ("taking powers")

2. multiplication and division 

3. additional and subtraction

If you find it difficult to remember this, there are a load of [mnemonics](http://en.wikipedia.org/wiki/Order_of_operations#Mnemonics) that are supposed to help. 

In order to get the answer we were looking for we need to take control of the order of evaluation. We do this by enclosing grouping the necessary bits of the calculation inside parentheses ("round brackets"). That is, we place `(` and `)` either side of them. The order in which expressions inside different pairs of parentheses are evaluated follows the rules you had to learn at school. The R expression we should have used is therefore:
```{r}
(2^3 - 6) / 2
```
We can use more than one pair of parentheses to control the order of evaluation in more complex calculations. For example, if we want to find the cube root of 2 (i.e. 2^1/3^) rather than 2^3^ in that last calculation we would instead write:
```{r}
(2^(1/3) - 6) / 2
```
The parentheses around the `1/3` in the exponent are needed to ensure this is evaluated prior to being used as the exponent.

### Problematic calculations

Now is a good time to highlight how R handles certain kinds of awkward numerical calculations. One of these involves division of a number by 0. Some programming languages will respond to an attempt to do this with an error. R is a bit more forgiving:
```{r}
1/0
```
Mathematically, division of a finite number by `0` equals A Very Large Number: infinity. R has a special built in data value that allows it to handle this kind of thing. This is `Inf`, which of course stands for "infinity". The other special kind of value we sometimes run into can be generated by numerical calculations that don't have a well-defined result. For example, it arises when we try to divide 0 or infinity by themselves:
```{r}
0/0
```
The `NaN` in this result stands for Not a Number. R produces `NaN` because $0/0$ is not defined mathematically: it produces something that is Not a Number. The reason we are pointing out `Inf` and `NaN` is not because we expect to use them. It's important to know what they represent because they often arise as a result of a mistake somewhere in a program. It's hard to track down such mistakes if we don't know how `Inf` and `NaN` arise.

That is enough about using R as a calculator for now. What we've seen---even though we haven't said it yet---is that R functions as a REPL: a read-eval-print loop (there's no need to remeber this term). R takes user input, evaluates it, prints the results, and then waits for the next input. This is handy, because it means we can use it interactively, working through an analysis line-by-line. However, to use R to solve for complex problems we need to learn how to store and reuse results. We'll look at this in the next section.

```{block, type="speed"}
#### Working efficiently at the Console

Working at the Console soon gets tedious if we have to retype similar things over and over again. There is no need to do this though. Place the cursor at the prompt and hit the up arrow. What happens? This brings back the last expression sent to R's interpreter. Hit the up arrow again to see the last-but-one expression, and so on. We go back down the list using the down arrow. Once we're at the line we need, we use the left and right arrows to move around the expression and the delete key to remove the parts we want to change. Once an expression has been edited like this we hit Enter to send it to R again. Try it!
```

## Storing and reusing results  {#assignment}

So far we've not tried to do anything remotely complicated or interesting, though we now know how to construct longer calculations using parentheses to control the order of evaluation. This approach is fine if the calculation is very simple. It quickly becomes unwieldy for dealing with anything more. The best way to see what we mean is by working through a simple example---solving a quadratic equation. Quandratic equations looks like this: $a + bx + cx^2 = 0$. If we know the values of $a$, $b$ and $c$ then we can solve this equation to find the values of $x$ that ensure the left hand side equals the right hand side. Here's the well-known formula for these solutions:
$$
x = \frac{-b\pm\sqrt{b^2-4ac}}{2a}
$$
Let's use R to calculate these solutions for us. Say that we want to find the solutions to the quadratic equation when $a=1$, $b=6$ and $c=5$. We just have to turn the above equation into a pair of R expressions:
```{r}
(-6 + (6^2 -4 * 1 * 5)^(1/2)) / (2 * 1)
```
```{r}
(-6 - (6^2 -4 * 1 * 5)^(1/2)) / (2 * 1)
```
The output tells us that the two values of $x$ that satisfy this particular quadratic equation are -1 and -5. What should we do if we now need to solve a different quadratic equation? Working at the Console, we could bring up the expressions we typed (using the up arrow) and then go through each of these, changing the numbers to match the new values of $a$, $b$ and $c$. Editing individual expressions like this is fairly tedious, and more importantly, it's fairly error prone because we have to make sure you substitute the right numbers in exactly the right positions.

A partial solution to this problem is to store the values of $a$, $b$ and $c$. We'll see precisely why this is useful in a moment. First, we need to learn how to store results in R. The key to this is to use the __assigment operator__, written as a left arrow ` <- `. Sticking with our original example, we need to store the numbers 1, 6 and 5. We do this using three expressions, one after the another: 
```{r}
a <- 1
```
```{r}
b <- 6
```
```{r}
c <- 5
```
What happened? Notice that R did not print anything to screen. This is because we first asked R to evaluate the expression on the right hand side of each ` <-` (just a number in this case) and then __assign the result__ of that evaluation instead of printing it. Each result has a name associated with it. These appear on the left hand side of the ` <- `.

The net result of all this is that we have stored the numbers 1, 6 and 5 somewhere in R, associating them with the letters `a`, `b` and `c`, respectively. What does this mean? Here's what happens if we type the letter `a` into the Console and hit Enter:
```{r}
a
```
It looks the same as if we had typed the number `1` directly into the Console. The result of typing `b` or `c` is hopefully obvious. What we just did was to store the output that results from evaluating three separate R expressions, associating each a name so that we can access them again^[Technically, this is called __binding__ the name to a value. You don't need to remember this.]. 

Whenever we use the assignment operator ` <- ` we are telling R to keep whatever kind of value results from the calculation on the right hand side of ` <- `,  giving it the name on the left hand side so that we can access it later. Why is this useful? Let's imagine we want to do more than one thing with our three numbers. If we want to know their sum or their product we can now use:
```{r}
a + b + c
```
```{r}
a * b * c
```
So once we've stored a result and associated it with a name we can reuse it wherever it's needed. Returning to our motivating example, we can now calculate the solutions to the quadratic equation by typing these two expressions into the Console:
```{r}
(-b + (b^2 -4 * a * c)^(1/2)) / (2 * a)
```
```{r}
(-b - (b^2 -4 * a * c)^(1/2)) / (2 * a)
```
Imagine we'd like to find the solutions to a different quadratic equation where $a=1$, $b=5$ and $c=5$. We just changed the value of $b$ here to keep things simple. To find our new solutions we have to do two things. First we change the value of the number associated with `b`...
```{r}
b <- 5
```
...then we bring up those lines that calculate the solutions to the quadratic equation and run them, one after the other:
```{r}
(-b + (b^2 -4 * a * c)^(1/2)) / (2 * a)
```
```{r}
(-b - (b^2 -4 * a * c)^(1/2)) / (2 * a)
```
We didn't have to retype those two expressions. We could just use the up arrow to bring each one back to the prompt and hit Enter. This is much simpler than editing the expressions. More importantly, we are beginning to see the benefits of using something like R: we can break down complex calculations into a series of steps, storing and reusing intermediate results as required.

```{block, type="info"}
#### Naming rules

We don't have to use a single letter to name things in R. We could have used the words `tom`, `dick` and `harry` in place of `a`, `b` and `c` if we had wanted to. It would be confusing for us, but it would be perfectly acceptable to R because `tom`, `dick` and `harry` are all legal names as far as it's concerned. Roughly speaking, a legal name in R is any sequence of letters, numbers, `.`, or `_`. The main constraint is that the sequence must begin with a letter.
```

### How does assignment work?

Before we finish up with this section we need to highlight a few more features of assignment in R. The first thing to note is that when we use the assignment operator ` <- ` to associate names and values, we informally refer to this as creating (or modifying) __a variable__. This is much less tedious than using words like "bind", "associate", value", and "name" all the time. Why is it called a variable? Ask yourself what happens when we run these lines:
```{r}
myvar <- 1
myvar <- 7
```
The first time we used ` <- ` with `myvar` on the left hand side we __created__ a variable `myvar` associated with the value 1. The second line `myvar <- 7` __modified__ the value of `myvar` to be 7. This is why we refer to `myvar` as a variable: we can change the its value as we please. What happened to the old value associated with `myvar`? In short, it is gone, kaput, lost... forever. The moment you assigned a new value to `myvar` the old one was destroyed and can no longer be accessed. Remember this.

Keep in mind that the expression on the right hand side of ` <- ` can be any kind of calculation, not just just a number. For example, if I want to store the number 1, associating it with `answer`, I could do this:
```{r}
answer <- (1 + 2^3) / (2 + 7)
```
That is a strange way to assign the number 1, but it illustrates the point. More generally, as along as the expression on the right hand side generates an output (an "object") it can be used with the assignment operator. For example, we can create new variables from old variables:
```{r}
newvar <- 2 * answer
```
What happened here? Start at the right hand side of ` <- `. The expression on this side contained the variable `answer` so R went to see if `answer` actually exists in the global environment. It does, so it then substituted the value associated with `answer` into the requested calculation, and then assigned the resulting value of 2 to `newvar`. We created a new variable `newvar` using information associated with `answer`.

Now look at what happens if we just copy a variable using the assignment operator:
```{r}
myvar <- 7
mycopy <- myvar
```
At this point we have two variables, `myvar` and `mycopy`, each associated with the number 7. There is something very important you need to realise here: each of these is associated with a __different copy__ of this number. If you change the value associated with one of these variables it does not change the value of the other, as this shows:
```{r}
myvar <- 10
```
```{r}
myvar
```
```{r}
mycopy
```
R always behaves like this unless you work very hard to alter this behaviour (we will never do this). So remember, every time you assign a variable to another, you make a completely new, independent copy of the value it is associated with. For our purposes this is a good thing because it makes it much easier to understand what a long sequence of R expressions will do (trust us on this one).


## Where do the objects we create live? 

We used the word "object" several times above to describe the result of a calculation. for a reason. In R-land, the word "object" just means "a thing R knows how to represent". R objects can be stored and reused. They can as simple as a set of one or more numbers, or a more complicated construct like a statistical model or a graphical description of some data. 

Whenever we associate a name with a value of some kind we create a copy of both these things somewhere in your computer's memory. We have to, otherwise how could we possibly access them again? In R the "somewhere" is called an environment. We won't get into a discussion of the different kinds of environments R uses---that's an advanced topic well beyond the scope of this book. The only environment we need to be aware of is the __Global Environment__, informally known as the Workspace. When you use the assignment operator ` <- ` at the Console the name-value pair you create is placed into the Global Environment. This is where all the different kinds of objects you create live by default. You can see a table of these in the __Environment__ tab in RStudio. There are two columns here. The first shows you the names, the second summarises the values.

The Global Environment is temporary. There are ways to save the Global Environment and restore it across different R sessions, but try not to get into the habit of doing this. Working this way only creates problems. Assume that when you shut down R/RStudio, everything in it is lost. If you need to store something you created while using R so that you can use it again, you should do this by writing a copy of it to a file. We will see how to do this later for datasets. 

## Spotting errors when they occur 

We may as well get something out of the way early on: you __will__ ask R to do something that turns out to contain an error. You will do this a lot! It's not a problem when this happens. When it does though, it's important to step back and work out what went wrong. Here is an example of what happens at the Console when you generate an error:
```{r, error=TRUE}
xyz + 2
```
In general terms, what happened is that R read in the instruction `xyz + 2`, tried to evaluate it, and found it could not. This is because the variable `xyz` does not exist. Upon running into the error, R printed something to the screen to tell us we have made a mistake ("Error: object 'xyz' not found"). 

When this happens we say R has "thrown an error". We know this because the message is in a warning colour (prbably red or orange---it depends how RStudio is set up) and it contains the word `Error`. The bit after the `:` is an attempt by R to tell me what went wrong. You should always __read your error messages__. They will be incomprehensible at first, but as you fix the many mistakes you will inevitably make, they will start to make more sense and become helpful (usually---sometimes they make no sense whatsoever, even to experienced users). This way of learning only works if you read the error messages in the first place though.





                                                                                                                                                                                                                                     


<!--chapter:end:1_02_R_calculator.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# Using scripts {#scripts}

```{block, type="warning"}
Working directly at the Console like this is the simplest way to use R. Generally speaking, we do not recommend working this way unless you only need to do something very simple which involves a handful of steps. For more complicated activities you should store your instructions in a script. We will look at how to do this at the end of this chapter. The aim of this section is to demonstrate how to use R to perform simple calculations and introduce a few key concepts that will help you understand how R works. At this stage -- for the purposes of learning how to use R -- typing expressions directly into the Console is fine.
```

We have seen that using variables is useful because it enables us to break down a problem into a series of simpler steps. So far however, we have only been working in the Console. If we want to reuse a calculation when we're working like this, we have to change a variable or two and then evaluate the expressions that do the job of solving an equation, make a graph, whatever. We also have to do all of this in the correct order, or things will not work as intended.

You can see that working in the Console is not going to be practical most of the time. So what should we do? The answer is: put your sequence of R expressions into a text file, called a __script__ (We already told you the answer earlier). Calling it a script makes it sound a bit fancy and clever---"I spent all day debugging my script". It is not. It is a boring text file that could be opend up in something like Notepad.exe. We just call it a script to signify the fact that the text contained in the file is a series of instructions telling our computer to do something.

To open a new script in RStudio navigate to `File > New File > R Script`. This will open the new file in a fourth pane. This pane is the Source Code Editor we mentioned earlier in the [What is RStudio]({{ site.baseurl }}/r-and-rstudio.html#what-is-rstudio)) section of the previous topic. Equivalently, we could refer to this as the Script Editor. The name of the tab this file lives in will be set to __Untitled1__ if you haven't opened any other new R Scripts. Here is what RStudio looks like on a Mac after we did this (we have highlighted the new pane with a red asterisk):

```{r, echo=FALSE}
embed_png("diagrams/RStudio-4-pane.png", dpi=500)
```

When you work with a script you type the required sequence of R expressions into the Editor pane, **not directly into the Console**. This is important---if you mix and match you will make mistakes. The worst of these is that you will write a script that seems to work, only to find it is broken when you open it up and use it again later. This usually happens because you typed something into the Console that is needed to make the whole script run when you were preparing it, but then forget to put it into the script. Just don't mix and match between using the Console and the Editor and you will avoid this.

The easiest way to appreciate the benefits of using a script is to work with one. If you have not already done so, open up a new script using `File > New File > R Script` and copy-paste this into the Editor pane:
```{r, eval=FALSE}
a <- 1
b <- 6
c <- 5

sqrt.b2ac <- (b^2 -4 * a * c)^(1/2)

(-b + sqrt.b2ac) / (2 * a)
(-b - sqrt.b2ac) / (2 * a)
```
Here is a partial screenshot of the Editor pane showing this script on our computer:

```{r, echo=FALSE}
embed_png("diagrams/editor-eg.png", dpi=200)
```

The first thing you will probably notice is that this Editor looks a little different from yours. We said earlier that RStudio was highly customisable. What we did above was change the way it does something called __syntax highlighting__. You can do this by navigating to `Tools > Global Options...`, selecting the `Appearance` button, and picking the `Cobalt` option under `Editor theme` (try it!). Syntax highlighting is a must have feature of any Editor. In a nutshell, syntax is a bit like the grammar of a computer language. It is the set of rules that determine how we form valid expressions, assign variables, and so on. The purpose of syntax highlighting is to draw attention to different components of syntax. You can see that when we use the Cobalt highlighting option, RStudio sets the background to black and displays variables in white, parentheses and arithmetic operators in orange, and numbers in red. It doesn't matter so much what the colours are. What matters is that we have a visual means to distinguish these different kinds of elements, making it much easier to read a script.

The other kind of elements RStudio has highlighted are in blue. We added these. They are called comments. Comments in R always start with a `#` symbol---this is called the "hash"" symbol if you are British (or the "pound" symbol if you are North American). **Lines that start with `#` are completely ignored by R**. They exist only to allow us, the developers of a script, to add notes and explanations that remind us how it all works. 

People have written long articles about how to use comments properly. We tried to read one once and very soon fell asleep. At this point we just want to emphasise that __you should use comments__ to remind yourself what your R code is supposed to be doing. Use them liberally to help you understand the logic of each script you write. This is another "take our word"" for it situation -- if you do not use comments, then when you come back to your precious script in a few weeks/months/years time you will have no idea what it does. 

The whole point of writing a script is ultimatley to run it. We could run the code in the above script by copying and pasting it into the Console. This is inefficient though. 

(By the way, the phrase "run our code" is shorthand for "send a number of R expressions to the R interpreter to be read and evaluated"). The latter is very tedious to write (and read) over and over again, so we will just write "run your/my/our code" from now on.)

Instead of relying on cut and paste, RStudio gives us different ways to run our code:

* There is a `Run` button at the top right of the Editor pane. As you might imagine, clicking on this will run some code. If you haven't highlighted anything in the Editor, this runs whichever line the cursor is at, i.e. it runs just that one line. If you had highlighted a region inside the Editor, this button will run all of that in sequence.

* We do not like clicking buttons. If you are like us, you are in luck. Pressing Control+Enter (or Command+Enter on a Mac) does exactly the same thing as the `Run` button. It also uses the same rules to decide which bits of code to run or not.

(You can also run lines of code via the `Code > Run Lines`. This is easily the most inefficient method after cut and paste. It is there in case you forget your keyboard shortcut or cannot remember where the run button is. We doubt that you will ever need it.)

Using which ever method you prefer, run every line in the script you just started. Here is what should happen at the Console when you do this:
```{r}
a <- 1
b <- 6
c <- 5

sqrt.b2ac <- (b^2 -4 * a * c)^(1/2)

(-b + sqrt.b2ac) / (2 * a)
(-b - sqrt.b2ac) / (2 * a)
```
This works exactly as though you had typed or pasted the sequence of R expressions into the Console, hitting Enter each time you get to the end of a line. What this means is that we can use this script to find the solutions to any quadratic equation with real roots (if you know what we mean by the phrase "real roots", great, if not, it does not really matter). All you have to do is edit the values assigned to `a`, `b` and `c` and then rerun **the whole script**. Do not rerun bits of it. Rerun it all. Try it. Just be sure to only use sets of values where $b^2 > 4ac$ or you will see the dreaded `NaN`.

<div class="warning-box">
#### The dreaded `+`
<div class="box-text">
Be careful when you highlight code to run. RStudio will run exactly the text you highlight. If you start or finish the highlighted region in the middle of an expression then one of three things will usually happen. If you are lucky you will generate an error, since you end up running only part an expression that is not itself a valid expression. We say this is lucky because the error will at least be easy to spot. If you are unlucky, you might end up running part an expression that _is_ itself a valid expression. This is harder to spot because it won't generate an error, and it will probably create problems further down the line. 

The third outcome is that your Console will look something like this (ignore the colours -- we am still using that Cobalt theme):

```{r, echo=FALSE}
embed_png("diagrams/dreaded-plus.png", dpi=250)
```

What happened? Look carefully at the little snippet of R code we sent to the Console. It is not a complete R expression because it is missing a closing parenthesis, `)`. When R receives only part of an expression like this, which has correct syntax but is not complete, it sits and waits for the rest of the expression. This is what the `+` at the Console signifies. When you see this happen you have two options. You can manually type in the missing part of the expression and hit Enter, or you can hit the Escape key to return you to the prompt `>` and start again. The first option is very error prone, so we would generally do the latter. 
</div>
</div>

Now that we have a script that does something a little useful we might wish to use it again. It is just a text file, so we can save the script as we would any other file. We can do this using the familiar menu-based approach (`File > Save As...`) or via the keyboard shortcut `Control+S` (or `Command+S` on a Mac). The only thing to keep in mind is that you should use the file extension `.R` or `.r`, e.g. `my_great_script.R`. This is because RStudio uses the file extension to detect the fact that a file is a script and not an ordinary text file. If you do not do this, then next time you open up the file in RStudio you won't be able to access the fancy Editor features like syntax highlighting, nor will you be able to send lines to the Console without using copy-paste.

From now on you should always work with scripts. No more typing into the Console!

<!--chapter:end:1_03_building_scripts.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# (PART) Data Wrangling {-} 


<!--chapter:end:2_00.Rmd-->

```{r include=FALSE, cache=FALSE}
library(dplyr)
library(ggplot2)
library(magrittr)

# Set plotting to bw plot default, but with transparent background elements. Note
# transparency requires the panel.background, plot.background, and device background
# all be set!

theme_update(plot.background = element_rect(fill = "transparent", colour = NA))


```
# (PART) Exporing Data {-}


<!--chapter:end:3_00.Rmd-->

